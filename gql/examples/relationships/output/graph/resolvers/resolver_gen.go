//go:build ignore
// +build ignore

package resolvers

// Code generated by graphqlgen. DO NOT EDIT.

import (
	"context"
	"reflect"

	"github.com/goliatone/go-crud"
	repository "github.com/goliatone/go-repository-bun"

	"graph/model"
)

type ScopeGuardFunc func(ctx context.Context, entity, action string) error
type ContextFactory func(ctx context.Context) crud.Context

func (r *Resolver) crudContext(ctx context.Context) crud.Context {
	if r.ContextFactory != nil {
		return r.ContextFactory(ctx)
	}
	return nil
}

func (r *Resolver) guard(ctx context.Context, entity, action string) error {
	if r.ScopeGuard != nil {
		if err := r.ScopeGuard(ctx, entity, action); err != nil {
			return err
		}
	}
	return nil
}

func buildCriteria(p *model.PaginationInput, order []*model.OrderByInput, filters []*model.FilterInput) []repository.SelectCriteria {
	return nil
}

func applyInput[T any, I any](dst *T, src I) {
	dv := reflect.ValueOf(dst).Elem()
	sv := reflect.ValueOf(src)
	if sv.Kind() == reflect.Pointer && !sv.IsNil() {
		sv = sv.Elem()
	}
	for i := 0; i < sv.NumField(); i++ {
		sf := sv.Field(i)
		df := dv.FieldByName(sv.Type().Field(i).Name)
		if !df.IsValid() || !df.CanSet() {
			continue
		}
		if sf.Kind() == reflect.Pointer {
			if sf.IsNil() {
				continue
			}
			df.Set(sf.Elem())
			continue
		}
		df.Set(sf)
	}
}

func setID[T any](dst *T, id string) {
	dv := reflect.ValueOf(dst).Elem()
	for _, name := range []string{"ID", "Id"} {
		f := dv.FieldByName(name)
		if f.IsValid() && f.CanSet() && f.Kind() == reflect.String {
			f.SetString(id)
			return
		}
	}
}

func (r *Resolver) AuthorService() crud.Service[model.Author] {
	if r.AuthorService == nil {
		panic("AuthorService is not configured on Resolver")
	}
	return r.AuthorService
}

func (r *Resolver) GetAuthor(ctx context.Context, id string) (*model.Author, error) {
	if err := r.guard(ctx, "Author", "show"); err != nil {
		return nil, err
	}
	record, err := r.AuthorService().Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListAuthor(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) ([]*model.Author, error) {
	if err := r.guard(ctx, "Author", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria(pagination, orderBy, filter)
	records, _, err := r.AuthorService().Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Author, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	return result, nil
}

func (r *Resolver) CreateAuthor(ctx context.Context, input model.CreateAuthorInput) (*model.Author, error) {
	if err := r.guard(ctx, "Author", "create"); err != nil {
		return nil, err
	}
	var record model.Author
	applyInput(&record, input)
	record, err := r.AuthorService().Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateAuthor(ctx context.Context, id string, input model.UpdateAuthorInput) (*model.Author, error) {
	if err := r.guard(ctx, "Author", "update"); err != nil {
		return nil, err
	}
	var record model.Author
	setID(&record, id)
	applyInput(&record, input)
	record, err := r.AuthorService().Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteAuthor(ctx context.Context, id string) (bool, error) {
	if err := r.guard(ctx, "Author", "delete"); err != nil {
		return false, err
	}
	var record model.Author
	setID(&record, id)
	if err := r.AuthorService().Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) AuthorProfileService() crud.Service[model.AuthorProfile] {
	if r.AuthorProfileService == nil {
		panic("AuthorProfileService is not configured on Resolver")
	}
	return r.AuthorProfileService
}

func (r *Resolver) GetAuthorProfile(ctx context.Context, id string) (*model.AuthorProfile, error) {
	if err := r.guard(ctx, "AuthorProfile", "show"); err != nil {
		return nil, err
	}
	record, err := r.AuthorProfileService().Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListAuthorProfile(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) ([]*model.AuthorProfile, error) {
	if err := r.guard(ctx, "AuthorProfile", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria(pagination, orderBy, filter)
	records, _, err := r.AuthorProfileService().Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	result := make([]*model.AuthorProfile, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	return result, nil
}

func (r *Resolver) CreateAuthorProfile(ctx context.Context, input model.CreateAuthorProfileInput) (*model.AuthorProfile, error) {
	if err := r.guard(ctx, "AuthorProfile", "create"); err != nil {
		return nil, err
	}
	var record model.AuthorProfile
	applyInput(&record, input)
	record, err := r.AuthorProfileService().Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateAuthorProfile(ctx context.Context, id string, input model.UpdateAuthorProfileInput) (*model.AuthorProfile, error) {
	if err := r.guard(ctx, "AuthorProfile", "update"); err != nil {
		return nil, err
	}
	var record model.AuthorProfile
	setID(&record, id)
	applyInput(&record, input)
	record, err := r.AuthorProfileService().Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteAuthorProfile(ctx context.Context, id string) (bool, error) {
	if err := r.guard(ctx, "AuthorProfile", "delete"); err != nil {
		return false, err
	}
	var record model.AuthorProfile
	setID(&record, id)
	if err := r.AuthorProfileService().Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) BookService() crud.Service[model.Book] {
	if r.BookService == nil {
		panic("BookService is not configured on Resolver")
	}
	return r.BookService
}

func (r *Resolver) GetBook(ctx context.Context, id string) (*model.Book, error) {
	if err := r.guard(ctx, "Book", "show"); err != nil {
		return nil, err
	}
	record, err := r.BookService().Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListBook(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) ([]*model.Book, error) {
	if err := r.guard(ctx, "Book", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria(pagination, orderBy, filter)
	records, _, err := r.BookService().Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Book, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	return result, nil
}

func (r *Resolver) CreateBook(ctx context.Context, input model.CreateBookInput) (*model.Book, error) {
	if err := r.guard(ctx, "Book", "create"); err != nil {
		return nil, err
	}
	var record model.Book
	applyInput(&record, input)
	record, err := r.BookService().Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateBook(ctx context.Context, id string, input model.UpdateBookInput) (*model.Book, error) {
	if err := r.guard(ctx, "Book", "update"); err != nil {
		return nil, err
	}
	var record model.Book
	setID(&record, id)
	applyInput(&record, input)
	record, err := r.BookService().Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteBook(ctx context.Context, id string) (bool, error) {
	if err := r.guard(ctx, "Book", "delete"); err != nil {
		return false, err
	}
	var record model.Book
	setID(&record, id)
	if err := r.BookService().Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) ChapterService() crud.Service[model.Chapter] {
	if r.ChapterService == nil {
		panic("ChapterService is not configured on Resolver")
	}
	return r.ChapterService
}

func (r *Resolver) GetChapter(ctx context.Context, id string) (*model.Chapter, error) {
	if err := r.guard(ctx, "Chapter", "show"); err != nil {
		return nil, err
	}
	record, err := r.ChapterService().Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListChapter(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) ([]*model.Chapter, error) {
	if err := r.guard(ctx, "Chapter", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria(pagination, orderBy, filter)
	records, _, err := r.ChapterService().Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Chapter, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	return result, nil
}

func (r *Resolver) CreateChapter(ctx context.Context, input model.CreateChapterInput) (*model.Chapter, error) {
	if err := r.guard(ctx, "Chapter", "create"); err != nil {
		return nil, err
	}
	var record model.Chapter
	applyInput(&record, input)
	record, err := r.ChapterService().Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateChapter(ctx context.Context, id string, input model.UpdateChapterInput) (*model.Chapter, error) {
	if err := r.guard(ctx, "Chapter", "update"); err != nil {
		return nil, err
	}
	var record model.Chapter
	setID(&record, id)
	applyInput(&record, input)
	record, err := r.ChapterService().Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteChapter(ctx context.Context, id string) (bool, error) {
	if err := r.guard(ctx, "Chapter", "delete"); err != nil {
		return false, err
	}
	var record model.Chapter
	setID(&record, id)
	if err := r.ChapterService().Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) HeadquartersService() crud.Service[model.Headquarters] {
	if r.HeadquartersService == nil {
		panic("HeadquartersService is not configured on Resolver")
	}
	return r.HeadquartersService
}

func (r *Resolver) GetHeadquarters(ctx context.Context, id string) (*model.Headquarters, error) {
	if err := r.guard(ctx, "Headquarters", "show"); err != nil {
		return nil, err
	}
	record, err := r.HeadquartersService().Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListHeadquarters(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) ([]*model.Headquarters, error) {
	if err := r.guard(ctx, "Headquarters", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria(pagination, orderBy, filter)
	records, _, err := r.HeadquartersService().Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Headquarters, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	return result, nil
}

func (r *Resolver) CreateHeadquarters(ctx context.Context, input model.CreateHeadquartersInput) (*model.Headquarters, error) {
	if err := r.guard(ctx, "Headquarters", "create"); err != nil {
		return nil, err
	}
	var record model.Headquarters
	applyInput(&record, input)
	record, err := r.HeadquartersService().Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateHeadquarters(ctx context.Context, id string, input model.UpdateHeadquartersInput) (*model.Headquarters, error) {
	if err := r.guard(ctx, "Headquarters", "update"); err != nil {
		return nil, err
	}
	var record model.Headquarters
	setID(&record, id)
	applyInput(&record, input)
	record, err := r.HeadquartersService().Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteHeadquarters(ctx context.Context, id string) (bool, error) {
	if err := r.guard(ctx, "Headquarters", "delete"); err != nil {
		return false, err
	}
	var record model.Headquarters
	setID(&record, id)
	if err := r.HeadquartersService().Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) PublishingHouseService() crud.Service[model.PublishingHouse] {
	if r.PublishingHouseService == nil {
		panic("PublishingHouseService is not configured on Resolver")
	}
	return r.PublishingHouseService
}

func (r *Resolver) GetPublishingHouse(ctx context.Context, id string) (*model.PublishingHouse, error) {
	if err := r.guard(ctx, "PublishingHouse", "show"); err != nil {
		return nil, err
	}
	record, err := r.PublishingHouseService().Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListPublishingHouse(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) ([]*model.PublishingHouse, error) {
	if err := r.guard(ctx, "PublishingHouse", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria(pagination, orderBy, filter)
	records, _, err := r.PublishingHouseService().Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	result := make([]*model.PublishingHouse, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	return result, nil
}

func (r *Resolver) CreatePublishingHouse(ctx context.Context, input model.CreatePublishingHouseInput) (*model.PublishingHouse, error) {
	if err := r.guard(ctx, "PublishingHouse", "create"); err != nil {
		return nil, err
	}
	var record model.PublishingHouse
	applyInput(&record, input)
	record, err := r.PublishingHouseService().Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdatePublishingHouse(ctx context.Context, id string, input model.UpdatePublishingHouseInput) (*model.PublishingHouse, error) {
	if err := r.guard(ctx, "PublishingHouse", "update"); err != nil {
		return nil, err
	}
	var record model.PublishingHouse
	setID(&record, id)
	applyInput(&record, input)
	record, err := r.PublishingHouseService().Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeletePublishingHouse(ctx context.Context, id string) (bool, error) {
	if err := r.guard(ctx, "PublishingHouse", "delete"); err != nil {
		return false, err
	}
	var record model.PublishingHouse
	setID(&record, id)
	if err := r.PublishingHouseService().Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) TagService() crud.Service[model.Tag] {
	if r.TagService == nil {
		panic("TagService is not configured on Resolver")
	}
	return r.TagService
}

func (r *Resolver) GetTag(ctx context.Context, id string) (*model.Tag, error) {
	if err := r.guard(ctx, "Tag", "show"); err != nil {
		return nil, err
	}
	record, err := r.TagService().Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListTag(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) ([]*model.Tag, error) {
	if err := r.guard(ctx, "Tag", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria(pagination, orderBy, filter)
	records, _, err := r.TagService().Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Tag, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	return result, nil
}

func (r *Resolver) CreateTag(ctx context.Context, input model.CreateTagInput) (*model.Tag, error) {
	if err := r.guard(ctx, "Tag", "create"); err != nil {
		return nil, err
	}
	var record model.Tag
	applyInput(&record, input)
	record, err := r.TagService().Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateTag(ctx context.Context, id string, input model.UpdateTagInput) (*model.Tag, error) {
	if err := r.guard(ctx, "Tag", "update"); err != nil {
		return nil, err
	}
	var record model.Tag
	setID(&record, id)
	applyInput(&record, input)
	record, err := r.TagService().Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteTag(ctx context.Context, id string) (bool, error) {
	if err := r.guard(ctx, "Tag", "delete"); err != nil {
		return false, err
	}
	var record model.Tag
	setID(&record, id)
	if err := r.TagService().Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	return true, nil
}
