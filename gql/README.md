# go-crud GraphQL generator (`gql/`)

GraphQL generator for go-crud.

## Quick start
- From the repo root, generate from a metadata JSON file:
```
go run ./gql/cmd/graphqlgen --metadata-file ./gql/examples/minimal/metadata.json --out graph --config gqlgen.yml
```
- Or rely on the in-memory schema registry (make sure your service packages register schemas before the CLI runs):
```
go run ./gql/cmd/graphqlgen --schema-package ./internal/yourapp
```
- Add auth snippets via hooks:
```
go run ./gql/cmd/graphqlgen \
  --schema-package ./internal/yourapp \
  --auth-guard "auth.FromContext(ctx)" \
  --auth-package github.com/goliatone/go-auth
```
- Emit subscription SDL/resolvers (defaults to `created/updated/deleted` per entity):
```
go run ./gql/cmd/graphqlgen --schema-package ./internal/yourapp --emit-subscriptions
```
- Use `github.com/goliatone/go-crud/gql/registrar` when you need a no-op router to register controllers for the schema registry.
- For examples/relationships-gql, `go generate` points `--schema-package` at `./registrar` so you can edit the Bun models in `model.go` and rerun codegen without maintaining a metadata.json (using the shared `gql/registrar` helper).
- List operations emit Relay connections (`XConnection`/`XEdge` + `PageInfo` with `total/hasNextPage/hasPreviousPage/startCursor/endCursor`) so Relay/Apollo clients can use pagination out of the box.
- Filter entities with `--include` / `--exclude`, override scalars with `--type-mapping string:uuid=UUID`, and add auth hooks via `--policy-hook yourpkg.CheckScope`.

## Output layout and safe edits
- Default layout: `graph/schema.graphql`, `gqlgen.yml`, `graph/resolvers/resolver_gen.go`, `graph/resolvers/resolver_custom.go`, optional `graph/dataloader/dataloader_gen.go`.
- `_gen` files regenerate on every run; `_custom` files are written once and never touched again unless you pass `--force`.
- Generated files carry `Code generated by graphqlgen. DO NOT EDIT.` headers; keep your code in `_custom` files.
- Go outputs are formatted with `goimports` (falling back to `gofmt`); diff-aware writes skip unchanged files. Use `--dry-run` to preview.

## Regenerating
- Rerun the CLI whenever metadata or templates change. Use `--template-dir` to point at custom templates without touching the embedded defaults.
- `--schema-package` now attempts to import the provided package before reading `crud.ListSchemas()`, returning a clear error if the package can't be resolved or doesn't register schemas.
- Set `--run-gqlgen` to invoke gqlgen after files are written; combine with `--skip-gqlgen` or `--dry-run` as needed.
- Omit mutation payload fields via `--omit-mutation-field field` or `--omit-mutation-field Entity.field`. Enable dataloaders with `--emit-dataloader`.

## Schema refresh hooks
- When content types are published at runtime, register a schema refresh hook to regenerate GraphQL artifacts from the schema registry:
```
refresh.RegisterSchemaRefresh(ctx, refresh.Options{
    Debounce: 250 * time.Millisecond,
    GeneratorOptions: generator.Options{
        SchemaPackage: "./internal/api",
        OutDir:        "graph",
        ConfigPath:    "gqlgen.yml",
    },
})
```

## Metadata sources
- `--metadata-file` expects JSON containing `router.SchemaMetadata` (single object, array, or `{ "schemas": [...] }`). The loader also understands `crud.SchemaEntry` wrappers from the schema registry.
- If `--metadata-file` is not provided, the CLI reads `crud.ListSchemas()`; ensure your controllers/packages are imported so their `init` hooks register schemas. This registry-first flow is the default; metadata.json is optional and can be emitted with a small dumper if you need fixtures/docs.
- `gql/examples/minimal` contains a tiny metadata payload plus the generator output snapshot under `output/`.

## CLI flags (essentials)
- `--out`, `--config` – output base dir and gqlgen config path.
- `--include`, `--exclude` – entity name globs.
- `--type-mapping type[:format[:gotyp]]=<Scalar>` – scalar overrides (e.g., `time.Time=Time` or `string:uuid=UUID`).
- `--hooks-file` – JSON/YAML overlay for hook snippets/imports (per-entity/per-operation); `--auth-guard`, `--auth-package`, `--auth-fail` seed default auth guards (with `errors.New("unauthorized")` fallback).
- `--emit-dataloader` – scaffold `graph/dataloader/dataloader_gen.go`.
- `--emit-subscriptions` – add subscription SDL/resolvers; `--subscription-event` (repeatable) overrides the default `created,updated,deleted` triggers.
- `--policy-hook` – call a scope-guard helper inside generated resolvers in addition to `Resolver.ScopeGuard`.
- `--goimports=false` – skip goimports/go fmt; `--force` – overwrite `_custom` stubs; `--dry-run` – no writes.

## GraphQL request context adapter
- Use `helpers.GraphQLToCrudContext(ctx)` (from `github.com/goliatone/go-crud/gql/helpers`) inside gqlgen resolvers to obtain a `crud.Context` for services.
- Behavior: `Params` read from GraphQL variables, `Query/Queries` are empty (use defaults), `BodyParser` copies variables into a struct, `Header` proxies gqlgen `OperationContext.Headers`, and `Status/JSON/SendStatus` are no-ops suited to resolver flows.
- The adapter is read-only; set user context metadata via `SetUserContext` if you need to attach actor/scope/request IDs before calling services.
- If you need richer semantics (e.g., HTTP path, IP extraction, mutable context), supply your own `crud.Context` implementation from the resolver instead of the helper.

## Service layer wiring (REST + GraphQL)
- Build the `crud.Service` once and reuse it for both routers:
```go
type Resolver struct {
    services struct {
        Book crud.Service[*model.Book]
    }
}

func NewResolver(repos *repositories.Repositories) *Resolver {
    bookService := crud.NewService(crud.ServiceConfig[*model.Book]{
        Repository: repos.Book,
        Hooks:      bookHooks,
        ScopeGuard: bookScopeGuard,
        FieldPolicy: bookFieldPolicy,
        VirtualFields: crud.NewVirtualFieldHandler[*model.Book](),
    })
    return &Resolver{services: struct{ Book crud.Service[*model.Book] }{bookService}}
}

func (r *mutationResolver) CreateBook(ctx context.Context, input model.BookInput) (*model.Book, error) {
    crudCtx := helpers.GraphQLToCrudContext(ctx)
    book := &model.Book{Title: input.Title, Status: input.Status}
    return r.services.Book.Create(crudCtx, book)
}
```
- REST can point at the same service with `crud.NewControllerWithService(repos.Book, bookService, crud.WithDeserializer(bookDeserializer))`; controller options still apply.
- Incremental path: start by feeding the shared service into GraphQL resolvers while REST uses its existing options, then flip REST to `NewControllerWithService` once parity tests pass.

## Integrating in a service
- Add a `//go:generate` near your resolver package (ensure the package that registers schemas is imported by the generator run):
```go
//go:generate go run ./gql/cmd/graphqlgen --schema-package ./internal/api --out graph --config gqlgen.yml
```
- Optional `make` target:
```make
graphql:
	go run ./gql/cmd/graphqlgen --out graph --config gqlgen.yml
```
- Keep `_custom` files under version control; rerun the generator after changing metadata, type mappings, or templates.

## Template engine
- Uses `github.com/goliatone/go-template` (Django/pongo2-style: `{% %}` blocks, `{{ }}` expressions). Filters from go-template are available; additional filters can be registered per renderer instance.

## Hooks (auth/scope/preload/wrapping/error)
- Overlay shape:
```yaml
hooks:
  imports:
    - github.com/goliatone/go-auth
  default:
    scope_guard: r.ScopeHook(ctx, entity, action)
  entities:
    post:
      operations:
        list:
          preload: criteria = append(criteria, repository.SelectRelation("Author"))
```
- Hook sets merge CLI defaults first, then overlays (overlay wins on conflicts). `--auth-guard` builds an auth snippet with zero-value returns and `errors.New("unauthorized")` unless you pass `--auth-fail`.
- Resolver templates expose hook slots via `entity.Hooks.<Op>.<Field>` (`Op` in {Get, List, Create, Update, Delete}); code blocks are marked `|safe` to avoid escaping.
- `graph/resolvers/resolver_custom.go` ships editable stubs for `AuthGuard`, `ScopeHook`, `PreloadHook`, `WrapService`, and `HandleError` so teams can centralize hook logic without forking templates.

## Subscriptions
- Enabling `--emit-subscriptions` adds `Subscription` operations per entity (default: `<entity>Created`, `<entity>Updated`, `<entity>Deleted`) and injects publish calls into create/update/delete resolvers.
- Generated `_custom` stubs declare an `EventBus` interface (`Publish(ctx, topic, payload)` / `Subscribe(ctx, topic) (<-chan EventMessage, error)`); generated resolvers wire topics as `<entity>.<event>`.
- Provide a bus implementation (e.g., in-memory or backed by your broker) and mount gqlgen with websocket transport (see the relationships-gql example for go-router wiring and a WebSocket smoke test).
