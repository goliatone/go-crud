package main

import (
	"bytes"
	"context"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

func TestCLI_Smoke(t *testing.T) {
	cwd, err := os.Getwd()
	require.NoError(t, err)

	root := filepath.Dir(filepath.Dir(cwd))
	metadataPath := filepath.Join(root, "internal", "templates", "testdata", "metadata.json")

	dir := t.TempDir()
	require.NoError(t, os.Chdir(dir))
	defer func() {
		_ = os.Chdir(cwd)
	}()

	var output bytes.Buffer
	err = run(context.Background(), []string{"--metadata-file", metadataPath, "--emit-dataloader"}, &output)
	require.NoError(t, err)

	assertFileExists(t, filepath.Join(dir, "graph", "schema.graphql"))
	assertFileExists(t, filepath.Join(dir, "graph", "model", "models_gen.go"))
	assertFileExists(t, filepath.Join(dir, "graph", "model", "models_custom.go"))
	assertFileExists(t, filepath.Join(dir, "graph", "resolvers", "resolver_gen.go"))
	assertFileExists(t, filepath.Join(dir, "graph", "resolvers", "resolver_custom.go"))
	assertFileExists(t, filepath.Join(dir, "graph", "dataloader", "dataloader_gen.go"))
	assertFileExists(t, filepath.Join(dir, "gqlgen.yml"))

	schema := readFile(t, filepath.Join(dir, "graph", "schema.graphql"))
	require.True(t, strings.Contains(schema, "Code generated by graphqlgen"), "schema file should include generated notice")

	resolverCustom := readFile(t, filepath.Join(dir, "graph", "resolvers", "resolver_custom.go"))
	require.True(t, strings.Contains(resolverCustom, "Custom resolver stubs"), "custom resolver stub should be written")

	paths := []string{
		filepath.Join(dir, "graph", "schema.graphql"),
		filepath.Join(dir, "graph", "model", "models_gen.go"),
		filepath.Join(dir, "graph", "model", "models_custom.go"),
		filepath.Join(dir, "graph", "resolvers", "resolver_gen.go"),
		filepath.Join(dir, "graph", "resolvers", "resolver_custom.go"),
		filepath.Join(dir, "graph", "dataloader", "dataloader_gen.go"),
		filepath.Join(dir, "gqlgen.yml"),
	}

	modTimes := make(map[string]time.Time, len(paths))
	contents := make(map[string]string, len(paths))
	for _, path := range paths {
		modTimes[path] = fileModTime(t, path)
		contents[path] = readFile(t, path)
	}

	var second bytes.Buffer
	err = run(context.Background(), []string{"--metadata-file", metadataPath, "--emit-dataloader"}, &second)
	require.NoError(t, err)

	for _, path := range paths {
		require.Equal(t, contents[path], readFile(t, path), "content should remain unchanged on second run for %s", path)
		require.True(t, modTimes[path].Equal(fileModTime(t, path)), "modtime should remain unchanged on second run for %s", path)
	}

	output2 := second.String()
	require.Contains(t, output2, "skipped_same", "expected diff-aware writer to skip unchanged generated files")
	require.Contains(t, output2, "skipped_exists", "expected custom stub to be skipped when already present")
}

func TestCLI_SchemaPackage(t *testing.T) {
	cwd, err := os.Getwd()
	require.NoError(t, err)

	outDir := filepath.Join(t.TempDir(), "graph")
	configPath := filepath.Join(filepath.Dir(outDir), "gqlgen.yml")

	var output bytes.Buffer
	err = run(context.Background(), []string{
		"--schema-package", "github.com/goliatone/go-crud/gql/testdata/registrar",
		"--out", outDir,
		"--config", configPath,
	}, &output)
	require.NoError(t, err, "cli should load schemas from schema-package")

	assertFileExists(t, filepath.Join(outDir, "schema.graphql"))

	schema := readFile(t, filepath.Join(outDir, "schema.graphql"))
	require.Contains(t, schema, "RegistryDemoConnection", "schema should include Relay connection types")
	require.Contains(t, output.String(), "schema.graphql")

	require.NoError(t, os.Chdir(cwd))
}

func TestCLI_SchemaPackage_Relationships(t *testing.T) {
	cwd, err := os.Getwd()
	require.NoError(t, err)

	repoRoot := filepath.Dir(filepath.Dir(filepath.Dir(cwd)))

	temp := t.TempDir()
	outDir := filepath.Join(temp, "graph")
	configPath := filepath.Join(temp, "gqlgen.yml")

	require.NoError(t, os.Chdir(repoRoot))
	defer func() { _ = os.Chdir(cwd) }()

	var buf bytes.Buffer
	err = run(context.Background(), []string{
		"--schema-package", "github.com/goliatone/go-crud/examples/relationships-gql/registrar",
		"--out", outDir,
		"--config", configPath,
	}, &buf)
	require.NoError(t, err)

	checkPaths := []string{
		filepath.Join(outDir, "schema.graphql"),
		filepath.Join(outDir, "model", "models_gen.go"),
		filepath.Join(outDir, "resolvers", "resolver_gen.go"),
		configPath,
	}
	for _, p := range checkPaths {
		assertFileExists(t, p)
	}

	schema := readFile(t, filepath.Join(outDir, "schema.graphql"))
	require.Contains(t, schema, "PublishingHouseConnection", "should emit schema from registrar models")

	modTimes := map[string]time.Time{}
	contents := map[string]string{}
	for _, p := range checkPaths {
		modTimes[p] = fileModTime(t, p)
		contents[p] = readFile(t, p)
	}

	var second bytes.Buffer
	err = run(context.Background(), []string{
		"--schema-package", "github.com/goliatone/go-crud/examples/relationships-gql/registrar",
		"--out", outDir,
		"--config", configPath,
	}, &second)
	require.NoError(t, err)

	for _, p := range checkPaths {
		require.Equal(t, contents[p], readFile(t, p))
		require.True(t, modTimes[p].Equal(fileModTime(t, p)), "modtime should remain unchanged for %s", p)
	}
	require.Contains(t, second.String(), "skipped_same", "expect diff-aware writer skip on rerun")
}

func assertFileExists(t *testing.T, path string) {
	t.Helper()
	if _, err := os.Stat(path); err != nil {
		t.Fatalf("expected file to exist: %s", path)
	}
}

func readFile(t *testing.T, path string) string {
	t.Helper()
	data, err := os.ReadFile(path)
	require.NoError(t, err)
	return string(data)
}

func fileModTime(t *testing.T, path string) time.Time {
	t.Helper()
	info, err := os.Stat(path)
	require.NoError(t, err)
	return info.ModTime()
}
