package main

import (
	"bytes"
	"context"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

func TestCLI_Smoke(t *testing.T) {
	cwd, err := os.Getwd()
	require.NoError(t, err)

	root := filepath.Dir(filepath.Dir(cwd))
	metadataPath := filepath.Join(root, "internal", "templates", "testdata", "metadata.json")

	dir := t.TempDir()
	require.NoError(t, os.Chdir(dir))
	defer func() {
		_ = os.Chdir(cwd)
	}()

	var output bytes.Buffer
	err = run(context.Background(), []string{"--metadata-file", metadataPath, "--emit-dataloader"}, &output)
	require.NoError(t, err)

	assertFileExists(t, filepath.Join(dir, "graph", "schema.graphql"))
	assertFileExists(t, filepath.Join(dir, "graph", "model", "models_gen.go"))
	assertFileExists(t, filepath.Join(dir, "graph", "model", "models_custom.go"))
	assertFileExists(t, filepath.Join(dir, "graph", "resolvers", "resolver_gen.go"))
	assertFileExists(t, filepath.Join(dir, "graph", "resolvers", "resolver_custom.go"))
	assertFileExists(t, filepath.Join(dir, "graph", "dataloader", "dataloader_gen.go"))
	assertFileExists(t, filepath.Join(dir, "gqlgen.yml"))

	schema := readFile(t, filepath.Join(dir, "graph", "schema.graphql"))
	require.True(t, strings.Contains(schema, "Code generated by graphqlgen"), "schema file should include generated notice")

	resolverCustom := readFile(t, filepath.Join(dir, "graph", "resolvers", "resolver_custom.go"))
	require.True(t, strings.Contains(resolverCustom, "Custom resolver stubs"), "custom resolver stub should be written")

	paths := []string{
		filepath.Join(dir, "graph", "schema.graphql"),
		filepath.Join(dir, "graph", "model", "models_gen.go"),
		filepath.Join(dir, "graph", "model", "models_custom.go"),
		filepath.Join(dir, "graph", "resolvers", "resolver_gen.go"),
		filepath.Join(dir, "graph", "resolvers", "resolver_custom.go"),
		filepath.Join(dir, "graph", "dataloader", "dataloader_gen.go"),
		filepath.Join(dir, "gqlgen.yml"),
	}

	modTimes := make(map[string]time.Time, len(paths))
	contents := make(map[string]string, len(paths))
	for _, path := range paths {
		modTimes[path] = fileModTime(t, path)
		contents[path] = readFile(t, path)
	}

	var second bytes.Buffer
	err = run(context.Background(), []string{"--metadata-file", metadataPath, "--emit-dataloader"}, &second)
	require.NoError(t, err)

	for _, path := range paths {
		require.Equal(t, contents[path], readFile(t, path), "content should remain unchanged on second run for %s", path)
		require.True(t, modTimes[path].Equal(fileModTime(t, path)), "modtime should remain unchanged on second run for %s", path)
	}

	output2 := second.String()
	require.Contains(t, output2, "skipped_same", "expected diff-aware writer to skip unchanged generated files")
	require.Contains(t, output2, "skipped_exists", "expected custom stub to be skipped when already present")
}

func assertFileExists(t *testing.T, path string) {
	t.Helper()
	if _, err := os.Stat(path); err != nil {
		t.Fatalf("expected file to exist: %s", path)
	}
}

func readFile(t *testing.T, path string) string {
	t.Helper()
	data, err := os.ReadFile(path)
	require.NoError(t, err)
	return string(data)
}

func fileModTime(t *testing.T, path string) time.Time {
	t.Helper()
	info, err := os.Stat(path)
	require.NoError(t, err)
	return info.ModTime()
}
