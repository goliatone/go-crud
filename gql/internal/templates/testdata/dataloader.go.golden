package dataloader

// Code generated by graphqlgen. DO NOT EDIT.

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"sync"

	"github.com/goliatone/go-crud"
	repository "github.com/goliatone/go-repository-bun"
	"github.com/uptrace/bun"

	"graph/model"
)

type contextKey struct{}

// Services bundles the CRUD services used by dataloaders.
type Services struct {
	Post crud.Service[model.Post]
	User crud.Service[model.User]
}

// Option configures a Loader.
type Option func(*Loader)

// WithDB provides a bun database or transaction for pivot-aware joins.
func WithDB(db bun.IDB) Option {
	return func(l *Loader) {
		l.db = db
	}
}

// WithContextFactory sets a factory used to build crud.Context values from request contexts.
func WithContextFactory(factory func(context.Context) crud.Context) Option {
	return func(l *Loader) {
		l.contextFactory = factory
	}
}

// Loader batches lookups to avoid N+1 database queries.
type Loader struct {
	services       Services
	db             bun.IDB
	contextFactory func(context.Context) crud.Context

	PostByID *entityLoader[model.Post]
	UserByID *entityLoader[model.User]
}

// New builds a Loader backed by the provided services.
func New(services Services, opts ...Option) *Loader {
	loader := &Loader{
		services: services,
	}
	for _, opt := range opts {
		if opt != nil {
			opt(loader)
		}
	}

	loader.PostByID = newEntityLoader(func(ctx context.Context, keys []string) (map[string]*model.Post, error) {
		return loader.fetchPostByID(ctx, loader.crudContext(ctx), loader.services.Post, "id", keys)
	})
	loader.UserByID = newEntityLoader(func(ctx context.Context, keys []string) (map[string]*model.User, error) {
		return loader.fetchUserByID(ctx, loader.crudContext(ctx), loader.services.User, "id", keys)
	})
	return loader
}

// Inject stores the loader in the provided context.
func Inject(ctx context.Context, loader *Loader) context.Context {
	return context.WithValue(ctx, contextKey{}, loader)
}

// FromContext extracts a loader if one was previously injected.
func FromContext(ctx context.Context) (*Loader, bool) {
	if ctx == nil {
		return nil, false
	}
	loader, ok := ctx.Value(contextKey{}).(*Loader)
	return loader, ok
}

func (l *Loader) crudContext(ctx context.Context) crud.Context {
	if l.contextFactory != nil {
		return l.contextFactory(ctx)
	}
	return nil
}

func (l *Loader) fetchPostByID(ctx context.Context, crudCtx crud.Context, svc crud.Service[model.Post], column string, keys []string) (map[string]*model.Post, error) {
	result := make(map[string]*model.Post, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := svc.Index(crudCtx, []repository.SelectCriteria{
		repository.SelectColumnIn(column, dedup),
	})
	if err != nil {
		return nil, err
	}

	for i := range records {
		record := records[i]
		result[stringValue(record.Id)] = &record
	}

	return result, nil
}

func (l *Loader) fetchUserByID(ctx context.Context, crudCtx crud.Context, svc crud.Service[model.User], column string, keys []string) (map[string]*model.User, error) {
	result := make(map[string]*model.User, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := svc.Index(crudCtx, []repository.SelectCriteria{
		repository.SelectColumnIn(column, dedup),
	})
	if err != nil {
		return nil, err
	}

	for i := range records {
		record := records[i]
		result[stringValue(record.Id)] = &record
	}

	return result, nil
}

type pivotLink struct {
	Source string `bun:"source_id"`
	Target string `bun:"target_id"`
}

func fetchPivotLinks(ctx context.Context, db bun.IDB, table, sourceColumn, targetColumn string, keys []string) ([]pivotLink, error) {
	rows := make([]pivotLink, 0, len(keys))
	if len(keys) == 0 {
		return rows, nil
	}

	err := db.NewSelect().
		Table(table).
		ColumnExpr("? AS source_id", bun.Ident(sourceColumn)).
		ColumnExpr("? AS target_id", bun.Ident(targetColumn)).
		Where(fmt.Sprintf("%s IN (?)", bun.Ident(sourceColumn)), bun.In(uniqueKeys(keys))).
		Scan(ctx, &rows)

	return rows, err
}

type entityLoader[T any] struct {
	fetch func(context.Context, []string) (map[string]*T, error)
	mu    sync.Mutex
	cache map[string]*T
}

func newEntityLoader[T any](fetch func(context.Context, []string) (map[string]*T, error)) *entityLoader[T] {
	return &entityLoader[T]{
		fetch: fetch,
		cache: make(map[string]*T),
	}
}

func (l *entityLoader[T]) Load(ctx context.Context, key string) (*T, error) {
	items, err := l.LoadMany(ctx, []string{key})
	if err != nil {
		return nil, err
	}
	return items[key], nil
}

func (l *entityLoader[T]) LoadMany(ctx context.Context, keys []string) (map[string]*T, error) {
	result := make(map[string]*T, len(keys))
	missing := make([]string, 0, len(keys))
	dedup := uniqueKeys(keys)

	l.mu.Lock()
	for _, key := range dedup {
		if val, ok := l.cache[key]; ok {
			result[key] = val
			continue
		}
		missing = append(missing, key)
	}
	l.mu.Unlock()

	if len(missing) > 0 {
		fetched, err := l.fetch(ctx, missing)
		if err != nil {
			return nil, err
		}
		l.mu.Lock()
		for key, val := range fetched {
			l.cache[key] = val
			result[key] = val
		}
		l.mu.Unlock()
	}

	for _, key := range dedup {
		if _, ok := result[key]; !ok {
			result[key] = nil
		}
	}

	return result, nil
}

type groupLoader[T any] struct {
	fetch func(context.Context, []string) (map[string][]*T, error)
	mu    sync.Mutex
	cache map[string][]*T
}

func newGroupLoader[T any](fetch func(context.Context, []string) (map[string][]*T, error)) *groupLoader[T] {
	return &groupLoader[T]{
		fetch: fetch,
		cache: make(map[string][]*T),
	}
}

func (l *groupLoader[T]) Load(ctx context.Context, key string) ([]*T, error) {
	items, err := l.LoadMany(ctx, []string{key})
	if err != nil {
		return nil, err
	}
	return items[key], nil
}

func (l *groupLoader[T]) LoadMany(ctx context.Context, keys []string) (map[string][]*T, error) {
	result := make(map[string][]*T, len(keys))
	missing := make([]string, 0, len(keys))
	dedup := uniqueKeys(keys)

	l.mu.Lock()
	for _, key := range dedup {
		if val, ok := l.cache[key]; ok {
			result[key] = val
			continue
		}
		missing = append(missing, key)
	}
	l.mu.Unlock()

	if len(missing) > 0 {
		fetched, err := l.fetch(ctx, missing)
		if err != nil {
			return nil, err
		}

		l.mu.Lock()
		for key, val := range fetched {
			l.cache[key] = val
			result[key] = val
		}
		l.mu.Unlock()
	}

	for _, key := range dedup {
		if _, ok := result[key]; !ok {
			result[key] = nil
		}
	}

	return result, nil
}

func uniqueKeys(keys []string) []string {
	seen := make(map[string]struct{}, len(keys))
	result := make([]string, 0, len(keys))
	for _, key := range keys {
		key = strings.TrimSpace(key)
		if key == "" {
			continue
		}
		if _, ok := seen[key]; ok {
			continue
		}
		seen[key] = struct{}{}
		result = append(result, key)
	}
	return result
}

func stringValue(value any) string {
	switch v := value.(type) {
	case nil:
		return ""
	case *string:
		if v == nil {
			return ""
		}
		return *v
	case fmt.Stringer:
		return v.String()
	default:
		return fmt.Sprint(v)
	}
}
