package resolvers

// Code generated by graphqlgen. DO NOT EDIT.

import (
	"context"
	"reflect"

	"github.com/goliatone/go-crud"
	repository "github.com/goliatone/go-repository-bun"

	"graph/model"
)

type ScopeGuardFunc func(ctx context.Context, entity, action string) error
type ContextFactory func(ctx context.Context) crud.Context

func (r *Resolver) crudContext(ctx context.Context) crud.Context {
	if r.ContextFactory != nil {
		return r.ContextFactory(ctx)
	}
	return nil
}

func (r *Resolver) guard(ctx context.Context, entity, action string) error {
	if r.ScopeGuard != nil {
		if err := r.ScopeGuard(ctx, entity, action); err != nil {
			return err
		}
	}
	return nil
}

func buildCriteria(p *model.PaginationInput, order []*model.OrderByInput, filters []*model.FilterInput) []repository.SelectCriteria {
	return nil
}

func applyInput[T any, I any](dst *T, src I) {
	dv := reflect.ValueOf(dst).Elem()
	sv := reflect.ValueOf(src)
	if sv.Kind() == reflect.Pointer && !sv.IsNil() {
		sv = sv.Elem()
	}
	for i := 0; i < sv.NumField(); i++ {
		sf := sv.Field(i)
		df := dv.FieldByName(sv.Type().Field(i).Name)
		if !df.IsValid() || !df.CanSet() {
			continue
		}
		if sf.Kind() == reflect.Pointer {
			if sf.IsNil() {
				continue
			}
			df.Set(sf.Elem())
			continue
		}
		df.Set(sf)
	}
}

func setID[T any](dst *T, id string) {
	dv := reflect.ValueOf(dst).Elem()
	for _, name := range []string{"ID", "Id"} {
		f := dv.FieldByName(name)
		if f.IsValid() && f.CanSet() && f.Kind() == reflect.String {
			f.SetString(id)
			return
		}
	}
}

func (r *Resolver) PostService() crud.Service[model.Post] {
	if r.PostSvc == nil {
		panic("PostService is not configured on Resolver")
	}
	return r.PostSvc
}

func (r *Resolver) GetPost(ctx context.Context, id string) (*model.Post, error) {
	if err := r.guard(ctx, "Post", "show"); err != nil {
		return nil, err
	}
	record, err := r.PostService().Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListPost(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) ([]*model.Post, error) {
	if err := r.guard(ctx, "Post", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria(pagination, orderBy, filter)
	records, _, err := r.PostService().Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	result := make([]*model.Post, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	return result, nil
}

func (r *Resolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
	if err := r.guard(ctx, "Post", "create"); err != nil {
		return nil, err
	}
	var record model.Post
	applyInput(&record, input)
	record, err := r.PostService().Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdatePost(ctx context.Context, id string, input model.UpdatePostInput) (*model.Post, error) {
	if err := r.guard(ctx, "Post", "update"); err != nil {
		return nil, err
	}
	var record model.Post
	setID(&record, id)
	applyInput(&record, input)
	record, err := r.PostService().Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeletePost(ctx context.Context, id string) (bool, error) {
	if err := r.guard(ctx, "Post", "delete"); err != nil {
		return false, err
	}
	var record model.Post
	setID(&record, id)
	if err := r.PostService().Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) UserService() crud.Service[model.User] {
	if r.UserSvc == nil {
		panic("UserService is not configured on Resolver")
	}
	return r.UserSvc
}

func (r *Resolver) GetUser(ctx context.Context, id string) (*model.User, error) {
	if err := r.guard(ctx, "User", "show"); err != nil {
		return nil, err
	}
	record, err := r.UserService().Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListUser(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) ([]*model.User, error) {
	if err := r.guard(ctx, "User", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria(pagination, orderBy, filter)
	records, _, err := r.UserService().Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	result := make([]*model.User, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	return result, nil
}

func (r *Resolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	if err := r.guard(ctx, "User", "create"); err != nil {
		return nil, err
	}
	var record model.User
	applyInput(&record, input)
	record, err := r.UserService().Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*model.User, error) {
	if err := r.guard(ctx, "User", "update"); err != nil {
		return nil, err
	}
	var record model.User
	setID(&record, id)
	applyInput(&record, input)
	record, err := r.UserService().Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	if err := r.guard(ctx, "User", "delete"); err != nil {
		return false, err
	}
	var record model.User
	setID(&record, id)
	if err := r.UserService().Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	return true, nil
}
