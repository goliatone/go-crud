package templates

import (
	"embed"
	"go/format"
	"strings"

	gotemplate "github.com/goliatone/go-template"

	"github.com/goliatone/go-crud/gql/internal/formatter"
)

const (
	SchemaTemplate         = "schema.tpl"
	GQLGenConfigTemplate   = "gqlgen.yml.tpl"
	ResolverGenTemplate    = "resolver_gen.tpl"
	ResolverCustomTemplate = "resolver_custom.tpl"
	DataloaderTemplate     = "dataloader.tpl"
	ModelsTemplate         = "models_gen.tpl"
	ModelsCustomTemplate   = "models_custom.tpl"

	GeneratedNotice = "Code generated by graphqlgen. DO NOT EDIT."
)

//go:embed *.tpl
var fs embed.FS

// NewRenderer returns a go-template renderer backed by the embedded templates.
func NewRenderer() (gotemplate.Renderer, error) {
	return NewRendererWithBaseDir("")
}

// NewRendererWithBaseDir returns a renderer that prefers templates in baseDir,
// falling back to the embedded defaults.
func NewRendererWithBaseDir(baseDir string) (gotemplate.Renderer, error) {
	opts := []gotemplate.Option{
		gotemplate.WithFS(fs),
		gotemplate.WithExtension(".tpl"),
	}
	if baseDir != "" {
		opts = append(opts, gotemplate.WithBaseDir(baseDir))
	}
	renderer, err := gotemplate.NewRenderer(opts...)
	if err != nil {
		return nil, err
	}

	registerWhitespaceHook(renderer)
	registerGoFmtHook(renderer)
	registerTrailingNewlineHook(renderer)

	return renderer, nil
}

// Context is the render context passed into templates.
type Context struct {
	Notice            string
	Entities          []formatter.Entity
	ResolverEntities  []formatter.Entity
	ModelPackage      string
	ResolverPackage   string
	DataloaderPackage string
	SchemaPath        string
	PolicyHook        string
	EmitDataloader    bool
	Scalars           []TemplateScalar
	Enums             []TemplateEnum
	Inputs            []TemplateInput
	Queries           []TemplateOperation
	Mutations         []TemplateOperation
	ModelStructs      []ModelStruct
	ModelEnums        []ModelEnum
	ModelImports      []string
	Criteria          map[string][]CriteriaField
}

type TemplateScalar struct {
	Name        string
	Description string
	GoType      string
}

type TemplateEnum struct {
	Name        string
	Description string
	Values      []TemplateEnumValue
}

type TemplateEnumValue struct {
	Name        string
	Description string
}

type TemplateInput struct {
	Name        string
	Description string
	Fields      []TemplateInputField
}

type TemplateInputField struct {
	Name        string
	Type        string
	Description string
	List        bool
	Required    bool
}

type TemplateOperation struct {
	Name          string
	ReturnType    string
	List          bool
	Required      bool
	Args          []TemplateArgument
	Description   string
	ArgsSignature string
}

type TemplateArgument struct {
	Name        string
	Type        string
	Description string
	List        bool
	Required    bool
}

// ModelStruct describes a Go struct to be generated for gqlgen models.
type ModelStruct struct {
	Name        string
	Description string
	Fields      []ModelField
}

// ModelField is a single field inside a generated Go struct.
type ModelField struct {
	Name     string
	JSONName string
	GoType   string
}

// ModelEnum captures a Go enum mapping for GraphQL enums.
type ModelEnum struct {
	Name   string
	Values []string
}

// CriteriaField captures mapping between GraphQL field paths and database columns.
type CriteriaField struct {
	Field    string
	Column   string
	Relation string
}

// NewContext builds a default context from a formatted document.
func NewContext(doc formatter.Document) Context {
	return Context{
		Notice:            GeneratedNotice,
		Entities:          doc.Entities,
		ModelPackage:      "graph/model",
		ResolverPackage:   "graph/resolvers",
		DataloaderPackage: "graph/dataloader",
		SchemaPath:        "graph/schema.graphql",
	}
}

func registerWhitespaceHook(renderer gotemplate.Renderer) {
	type postHookRegistrar interface {
		RegisterPostHook(gotemplate.PostHook)
	}

	hookable, ok := renderer.(postHookRegistrar)
	if !ok {
		return
	}

	hookable.RegisterPostHook(func(ctx *gotemplate.HookContext) (string, error) {
		dropBeforeBrace := ctx.TemplateName == SchemaTemplate
		cleaned := normalizeWhitespaceWithOptions(ctx.Output, dropBeforeBrace)
		ctx.Output = cleaned
		return cleaned, nil
	})
}

func registerTrailingNewlineHook(renderer gotemplate.Renderer) {
	type postHookRegistrar interface {
		RegisterPostHook(gotemplate.PostHook)
	}

	hookable, ok := renderer.(postHookRegistrar)
	if !ok {
		return
	}

	hookable.RegisterPostHook(func(ctx *gotemplate.HookContext) (string, error) {
		if ctx.TemplateName == ModelsCustomTemplate || ctx.TemplateName == ResolverCustomTemplate {
			if strings.HasSuffix(ctx.Output, "\n") {
				return ctx.Output, nil
			}
			ctx.Output += "\n"
			return ctx.Output, nil
		}

		ctx.Output = strings.TrimRight(ctx.Output, "\n") + "\n"
		return ctx.Output, nil
	})
}

func normalizeWhitespace(input string) string {
	return normalizeWhitespaceWithOptions(input, false)
}

func normalizeWhitespaceWithOptions(input string, dropBeforeBrace bool) string {
	lines := strings.Split(input, "\n")
	out := make([]string, 0, len(lines))
	emptyCount := 0
	hasTrailingBlank := false
	hadTrailingNewline := strings.HasSuffix(input, "\n")

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		if trimmed == "" {
			emptyCount++
			continue
		}

		if dropBeforeBrace && trimmed == "}" && emptyCount > 0 {
			emptyCount = 0
		} else if emptyCount > 1 {
			emptyCount = 1
		}

		for emptyCount > 0 {
			out = append(out, "")
			emptyCount--
		}

		out = append(out, line)
	}

	if emptyCount > 1 && hadTrailingNewline {
		hasTrailingBlank = true
	}

	result := strings.TrimRight(strings.Join(out, "\n"), "\n")

	switch {
	case hasTrailingBlank:
		result += "\n\n"
	case hadTrailingNewline:
		result += "\n"
	}

	return result
}

func registerGoFmtHook(renderer gotemplate.Renderer) {
	type postHookRegistrar interface {
		RegisterPostHook(gotemplate.PostHook)
	}

	hookable, ok := renderer.(postHookRegistrar)
	if !ok {
		return
	}

	hookable.RegisterPostHook(func(ctx *gotemplate.HookContext) (string, error) {
		switch ctx.TemplateName {
		case ModelsTemplate, ResolverGenTemplate, DataloaderTemplate:
			formatted, err := format.Source([]byte(ctx.Output))
			if err != nil {
				return ctx.Output, nil
			}
			ctx.Output = string(formatted)
			return ctx.Output, nil
		default:
			return ctx.Output, nil
		}
	})
}
