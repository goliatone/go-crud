package resolvers

// Code generated by graphqlgen. DO NOT EDIT.

import (
	"context"
	"encoding/base64"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/goliatone/go-crud/gql/helpers"

	"errors"
	"github.com/goliatone/go-auth"

	"github.com/goliatone/go-crud"
	repository "github.com/goliatone/go-repository-bun"
	"github.com/uptrace/bun"

	"github.com/goliatone/go-crud/examples/relationships-gql/graph/dataloader"

	"github.com/goliatone/go-crud/examples/relationships-gql/graph/model"
)

type ScopeGuardFunc func(ctx context.Context, entity, action string) error
type ContextFactory func(ctx context.Context) crud.Context

type criteriaField struct {
	Column       string
	Relation     string
	RelationType string
	PivotTable   string
	SourceColumn string
	TargetColumn string
	SourcePivot  string
	TargetPivot  string
	TargetTable  string
}

var criteriaConfig = map[string]map[string]criteriaField{

	"Author": {

		"active":                  {Column: "active"},
		"books.authorid":          {Column: "books.author_id", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.createdat":         {Column: "books.created_at", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.id":                {Column: "books.id", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.isbn":              {Column: "books.isbn", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.lastreprintat":     {Column: "books.last_reprint_at", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.publisherid":       {Column: "books.publisher_id", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.releasedate":       {Column: "books.release_date", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.status":            {Column: "books.status", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.title":             {Column: "books.title", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.updatedat":         {Column: "books.updated_at", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"createdat":               {Column: "created_at"},
		"email":                   {Column: "email"},
		"fullname":                {Column: "full_name"},
		"hiredat":                 {Column: "hired_at"},
		"id":                      {Column: "id"},
		"penname":                 {Column: "pen_name"},
		"profile.authorid":        {Column: "profile.author_id", Relation: "Profile", RelationType: "hasOne", SourceColumn: "id", TargetColumn: "id", TargetTable: "profile"},
		"profile.biography":       {Column: "profile.biography", Relation: "Profile", RelationType: "hasOne", SourceColumn: "id", TargetColumn: "id", TargetTable: "profile"},
		"profile.favoritegenre":   {Column: "profile.favorite_genre", Relation: "Profile", RelationType: "hasOne", SourceColumn: "id", TargetColumn: "id", TargetTable: "profile"},
		"profile.id":              {Column: "profile.id", Relation: "Profile", RelationType: "hasOne", SourceColumn: "id", TargetColumn: "id", TargetTable: "profile"},
		"profile.writingstyle":    {Column: "profile.writing_style", Relation: "Profile", RelationType: "hasOne", SourceColumn: "id", TargetColumn: "id", TargetTable: "profile"},
		"publisher.createdat":     {Column: "publisher.created_at", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.establishedat": {Column: "publisher.established_at", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.id":            {Column: "publisher.id", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.imprintprefix": {Column: "publisher.imprint_prefix", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.name":          {Column: "publisher.name", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.updatedat":     {Column: "publisher.updated_at", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisherid":             {Column: "publisher_id"},
		"tags.category":           {Column: "tags.category", Relation: "Tags", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "author_id", TargetPivot: "tag_id", TargetTable: "tags"},
		"tags.createdat":          {Column: "tags.created_at", Relation: "Tags", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "author_id", TargetPivot: "tag_id", TargetTable: "tags"},
		"tags.description":        {Column: "tags.description", Relation: "Tags", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "author_id", TargetPivot: "tag_id", TargetTable: "tags"},
		"tags.id":                 {Column: "tags.id", Relation: "Tags", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "author_id", TargetPivot: "tag_id", TargetTable: "tags"},
		"tags.name":               {Column: "tags.name", Relation: "Tags", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "author_id", TargetPivot: "tag_id", TargetTable: "tags"},
		"updatedat":               {Column: "updated_at"},
	},

	"AuthorProfile": {

		"author.active":      {Column: "author.active", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.createdat":   {Column: "author.created_at", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.email":       {Column: "author.email", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.fullname":    {Column: "author.full_name", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.hiredat":     {Column: "author.hired_at", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.id":          {Column: "author.id", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.penname":     {Column: "author.pen_name", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.publisherid": {Column: "author.publisher_id", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.updatedat":   {Column: "author.updated_at", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"authorid":           {Column: "author_id"},
		"biography":          {Column: "biography"},
		"favoritegenre":      {Column: "favorite_genre"},
		"id":                 {Column: "id"},
		"writingstyle":       {Column: "writing_style"},
	},

	"Book": {

		"author.active":           {Column: "author.active", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.createdat":        {Column: "author.created_at", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.email":            {Column: "author.email", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.fullname":         {Column: "author.full_name", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.hiredat":          {Column: "author.hired_at", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.id":               {Column: "author.id", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.penname":          {Column: "author.pen_name", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.publisherid":      {Column: "author.publisher_id", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"author.updatedat":        {Column: "author.updated_at", Relation: "Author", RelationType: "belongsTo", SourceColumn: "author_id", TargetColumn: "id", TargetTable: "author"},
		"authorid":                {Column: "author_id"},
		"chapters.bookid":         {Column: "chapters.book_id", Relation: "Chapters", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "chapters"},
		"chapters.chapterindex":   {Column: "chapters.chapter_index", Relation: "Chapters", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "chapters"},
		"chapters.id":             {Column: "chapters.id", Relation: "Chapters", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "chapters"},
		"chapters.title":          {Column: "chapters.title", Relation: "Chapters", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "chapters"},
		"chapters.wordcount":      {Column: "chapters.word_count", Relation: "Chapters", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "chapters"},
		"createdat":               {Column: "created_at"},
		"id":                      {Column: "id"},
		"isbn":                    {Column: "isbn"},
		"lastreprintat":           {Column: "last_reprint_at"},
		"publisher.createdat":     {Column: "publisher.created_at", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.establishedat": {Column: "publisher.established_at", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.id":            {Column: "publisher.id", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.imprintprefix": {Column: "publisher.imprint_prefix", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.name":          {Column: "publisher.name", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.updatedat":     {Column: "publisher.updated_at", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisherid":             {Column: "publisher_id"},
		"releasedate":             {Column: "release_date"},
		"status":                  {Column: "status"},
		"tags.category":           {Column: "tags.category", Relation: "Tags", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "book_id", TargetPivot: "tag_id", TargetTable: "tags"},
		"tags.createdat":          {Column: "tags.created_at", Relation: "Tags", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "book_id", TargetPivot: "tag_id", TargetTable: "tags"},
		"tags.description":        {Column: "tags.description", Relation: "Tags", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "book_id", TargetPivot: "tag_id", TargetTable: "tags"},
		"tags.id":                 {Column: "tags.id", Relation: "Tags", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "book_id", TargetPivot: "tag_id", TargetTable: "tags"},
		"tags.name":               {Column: "tags.name", Relation: "Tags", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "book_id", TargetPivot: "tag_id", TargetTable: "tags"},
		"title":                   {Column: "title"},
		"updatedat":               {Column: "updated_at"},
	},

	"Chapter": {

		"book.authorid":      {Column: "book.author_id", Relation: "Book", RelationType: "belongsTo", SourceColumn: "book_id", TargetColumn: "id", TargetTable: "book"},
		"book.createdat":     {Column: "book.created_at", Relation: "Book", RelationType: "belongsTo", SourceColumn: "book_id", TargetColumn: "id", TargetTable: "book"},
		"book.id":            {Column: "book.id", Relation: "Book", RelationType: "belongsTo", SourceColumn: "book_id", TargetColumn: "id", TargetTable: "book"},
		"book.isbn":          {Column: "book.isbn", Relation: "Book", RelationType: "belongsTo", SourceColumn: "book_id", TargetColumn: "id", TargetTable: "book"},
		"book.lastreprintat": {Column: "book.last_reprint_at", Relation: "Book", RelationType: "belongsTo", SourceColumn: "book_id", TargetColumn: "id", TargetTable: "book"},
		"book.publisherid":   {Column: "book.publisher_id", Relation: "Book", RelationType: "belongsTo", SourceColumn: "book_id", TargetColumn: "id", TargetTable: "book"},
		"book.releasedate":   {Column: "book.release_date", Relation: "Book", RelationType: "belongsTo", SourceColumn: "book_id", TargetColumn: "id", TargetTable: "book"},
		"book.status":        {Column: "book.status", Relation: "Book", RelationType: "belongsTo", SourceColumn: "book_id", TargetColumn: "id", TargetTable: "book"},
		"book.title":         {Column: "book.title", Relation: "Book", RelationType: "belongsTo", SourceColumn: "book_id", TargetColumn: "id", TargetTable: "book"},
		"book.updatedat":     {Column: "book.updated_at", Relation: "Book", RelationType: "belongsTo", SourceColumn: "book_id", TargetColumn: "id", TargetTable: "book"},
		"bookid":             {Column: "book_id"},
		"chapterindex":       {Column: "chapter_index"},
		"id":                 {Column: "id"},
		"title":              {Column: "title"},
		"wordcount":          {Column: "word_count"},
	},

	"Headquarters": {

		"addressline1":            {Column: "address_line1"},
		"addressline2":            {Column: "address_line2"},
		"city":                    {Column: "city"},
		"country":                 {Column: "country"},
		"id":                      {Column: "id"},
		"openedat":                {Column: "opened_at"},
		"publisher.createdat":     {Column: "publisher.created_at", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.establishedat": {Column: "publisher.established_at", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.id":            {Column: "publisher.id", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.imprintprefix": {Column: "publisher.imprint_prefix", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.name":          {Column: "publisher.name", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisher.updatedat":     {Column: "publisher.updated_at", Relation: "Publisher", RelationType: "belongsTo", SourceColumn: "publisher_id", TargetColumn: "id", TargetTable: "publisher"},
		"publisherid":             {Column: "publisher_id"},
	},

	"PublishingHouse": {

		"authors.active":            {Column: "authors.active", Relation: "Authors", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "authors"},
		"authors.createdat":         {Column: "authors.created_at", Relation: "Authors", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "authors"},
		"authors.email":             {Column: "authors.email", Relation: "Authors", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "authors"},
		"authors.fullname":          {Column: "authors.full_name", Relation: "Authors", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "authors"},
		"authors.hiredat":           {Column: "authors.hired_at", Relation: "Authors", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "authors"},
		"authors.id":                {Column: "authors.id", Relation: "Authors", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "authors"},
		"authors.penname":           {Column: "authors.pen_name", Relation: "Authors", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "authors"},
		"authors.publisherid":       {Column: "authors.publisher_id", Relation: "Authors", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "authors"},
		"authors.updatedat":         {Column: "authors.updated_at", Relation: "Authors", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "authors"},
		"books.authorid":            {Column: "books.author_id", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.createdat":           {Column: "books.created_at", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.id":                  {Column: "books.id", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.isbn":                {Column: "books.isbn", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.lastreprintat":       {Column: "books.last_reprint_at", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.publisherid":         {Column: "books.publisher_id", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.releasedate":         {Column: "books.release_date", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.status":              {Column: "books.status", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.title":               {Column: "books.title", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"books.updatedat":           {Column: "books.updated_at", Relation: "Books", RelationType: "hasMany", SourceColumn: "id", TargetColumn: "id", TargetTable: "books"},
		"createdat":                 {Column: "created_at"},
		"establishedat":             {Column: "established_at"},
		"headquarters.addressline1": {Column: "headquarters.address_line1", Relation: "Headquarters", RelationType: "hasOne", SourceColumn: "id", TargetColumn: "id", TargetTable: "headquarters"},
		"headquarters.addressline2": {Column: "headquarters.address_line2", Relation: "Headquarters", RelationType: "hasOne", SourceColumn: "id", TargetColumn: "id", TargetTable: "headquarters"},
		"headquarters.city":         {Column: "headquarters.city", Relation: "Headquarters", RelationType: "hasOne", SourceColumn: "id", TargetColumn: "id", TargetTable: "headquarters"},
		"headquarters.country":      {Column: "headquarters.country", Relation: "Headquarters", RelationType: "hasOne", SourceColumn: "id", TargetColumn: "id", TargetTable: "headquarters"},
		"headquarters.id":           {Column: "headquarters.id", Relation: "Headquarters", RelationType: "hasOne", SourceColumn: "id", TargetColumn: "id", TargetTable: "headquarters"},
		"headquarters.openedat":     {Column: "headquarters.opened_at", Relation: "Headquarters", RelationType: "hasOne", SourceColumn: "id", TargetColumn: "id", TargetTable: "headquarters"},
		"headquarters.publisherid":  {Column: "headquarters.publisher_id", Relation: "Headquarters", RelationType: "hasOne", SourceColumn: "id", TargetColumn: "id", TargetTable: "headquarters"},
		"id":                        {Column: "id"},
		"imprintprefix":             {Column: "imprint_prefix"},
		"name":                      {Column: "name"},
		"updatedat":                 {Column: "updated_at"},
	},

	"Tag": {

		"authors.active":      {Column: "authors.active", Relation: "Authors", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "author_id", TargetTable: "authors"},
		"authors.createdat":   {Column: "authors.created_at", Relation: "Authors", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "author_id", TargetTable: "authors"},
		"authors.email":       {Column: "authors.email", Relation: "Authors", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "author_id", TargetTable: "authors"},
		"authors.fullname":    {Column: "authors.full_name", Relation: "Authors", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "author_id", TargetTable: "authors"},
		"authors.hiredat":     {Column: "authors.hired_at", Relation: "Authors", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "author_id", TargetTable: "authors"},
		"authors.id":          {Column: "authors.id", Relation: "Authors", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "author_id", TargetTable: "authors"},
		"authors.penname":     {Column: "authors.pen_name", Relation: "Authors", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "author_id", TargetTable: "authors"},
		"authors.publisherid": {Column: "authors.publisher_id", Relation: "Authors", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "author_id", TargetTable: "authors"},
		"authors.updatedat":   {Column: "authors.updated_at", Relation: "Authors", RelationType: "manyToMany", PivotTable: "author_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "author_id", TargetTable: "authors"},
		"books.authorid":      {Column: "books.author_id", Relation: "Books", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "book_id", TargetTable: "books"},
		"books.createdat":     {Column: "books.created_at", Relation: "Books", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "book_id", TargetTable: "books"},
		"books.id":            {Column: "books.id", Relation: "Books", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "book_id", TargetTable: "books"},
		"books.isbn":          {Column: "books.isbn", Relation: "Books", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "book_id", TargetTable: "books"},
		"books.lastreprintat": {Column: "books.last_reprint_at", Relation: "Books", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "book_id", TargetTable: "books"},
		"books.publisherid":   {Column: "books.publisher_id", Relation: "Books", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "book_id", TargetTable: "books"},
		"books.releasedate":   {Column: "books.release_date", Relation: "Books", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "book_id", TargetTable: "books"},
		"books.status":        {Column: "books.status", Relation: "Books", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "book_id", TargetTable: "books"},
		"books.title":         {Column: "books.title", Relation: "Books", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "book_id", TargetTable: "books"},
		"books.updatedat":     {Column: "books.updated_at", Relation: "Books", RelationType: "manyToMany", PivotTable: "book_tags", SourceColumn: "id", TargetColumn: "id", SourcePivot: "tag_id", TargetPivot: "book_id", TargetTable: "books"},
		"category":            {Column: "category"},
		"createdat":           {Column: "created_at"},
		"description":         {Column: "description"},
		"id":                  {Column: "id"},
		"name":                {Column: "name"},
	},
}

func findOriginalNameForJoinKey(entity, joinKey string) string {
	joinKey = strings.ToLower(strings.TrimSpace(joinKey))
	if joinKey == "" {
		return ""
	}
	base := strings.SplitN(joinKey, ".", 2)[0]
	fields, ok := criteriaConfig[entity]
	if !ok {
		return base
	}
	if field, ok := fields[base]; ok && field.Relation != "" {
		return field.Relation
	}
	for key, field := range fields {
		prefix := strings.SplitN(key, ".", 2)[0]
		if prefix == base && field.Relation != "" {
			return field.Relation
		}
	}
	return base
}

var subscriptionTopics = map[string]map[string]string{}

func init() {
	addSubscriptionTopic("Author", "created", "author.created")
	addSubscriptionTopic("Author", "updated", "author.updated")
	addSubscriptionTopic("Author", "deleted", "author.deleted")
	addSubscriptionTopic("AuthorProfile", "created", "authorProfile.created")
	addSubscriptionTopic("AuthorProfile", "updated", "authorProfile.updated")
	addSubscriptionTopic("AuthorProfile", "deleted", "authorProfile.deleted")
	addSubscriptionTopic("Book", "created", "book.created")
	addSubscriptionTopic("Book", "updated", "book.updated")
	addSubscriptionTopic("Book", "deleted", "book.deleted")
	addSubscriptionTopic("Chapter", "created", "chapter.created")
	addSubscriptionTopic("Chapter", "updated", "chapter.updated")
	addSubscriptionTopic("Chapter", "deleted", "chapter.deleted")
	addSubscriptionTopic("Headquarters", "created", "headquarters.created")
	addSubscriptionTopic("Headquarters", "updated", "headquarters.updated")
	addSubscriptionTopic("Headquarters", "deleted", "headquarters.deleted")
	addSubscriptionTopic("PublishingHouse", "created", "publishingHouse.created")
	addSubscriptionTopic("PublishingHouse", "updated", "publishingHouse.updated")
	addSubscriptionTopic("PublishingHouse", "deleted", "publishingHouse.deleted")
	addSubscriptionTopic("Tag", "created", "tag.created")
	addSubscriptionTopic("Tag", "updated", "tag.updated")
	addSubscriptionTopic("Tag", "deleted", "tag.deleted")
}

func addSubscriptionTopic(entity, event, topic string) {
	if topic == "" {
		return
	}
	if subscriptionTopics[entity] == nil {
		subscriptionTopics[entity] = make(map[string]string)
	}
	subscriptionTopics[entity][strings.ToLower(event)] = topic
}

func subscriptionTopic(entity, event string) string {
	events, ok := subscriptionTopics[entity]
	if !ok {
		return ""
	}
	return events[strings.ToLower(event)]
}

func hasSubscription(entity, event string) bool {
	return subscriptionTopic(entity, event) != ""
}

func GraphQLContext(ctx context.Context) crud.Context {
	crudCtx := helpers.GraphQLToCrudContext(ctx)
	if crudCtx == nil {
		return nil
	}

	base := crudCtx.UserContext()
	if existing := crud.ActorFromContext(base); !existing.IsZero() {
		return crudCtx
	}

	actor, ok := auth.ActorFromContext(base)
	if !ok || actor == nil {
		return crudCtx
	}

	mapped := crud.ActorContext{
		ActorID:        actor.ActorID,
		Subject:        actor.Subject,
		Role:           actor.Role,
		ResourceRoles:  actor.ResourceRoles,
		TenantID:       actor.TenantID,
		OrganizationID: actor.OrganizationID,
		Metadata:       actor.Metadata,
		ImpersonatorID: actor.ImpersonatorID,
		IsImpersonated: actor.IsImpersonated,
	}

	updated := crud.ContextWithActor(base, mapped)
	if setter, ok := crudCtx.(interface{ SetUserContext(context.Context) }); ok && updated != nil {
		setter.SetUserContext(updated)
	}
	return crudCtx
}

func (r *Resolver) crudContext(ctx context.Context) crud.Context {
	if r.ContextFactory != nil {
		return r.ContextFactory(ctx)
	}
	return GraphQLContext(ctx)
}

func (r *Resolver) guard(ctx context.Context, entity, action string) error {
	if r.ScopeGuard != nil {
		if err := r.ScopeGuard(ctx, entity, action); err != nil {
			return err
		}
	}
	return nil
}

func (r *Resolver) publishEvent(ctx context.Context, entity, event string, payload any) error {
	if r.Events == nil {
		return nil
	}
	topic := subscriptionTopic(entity, event)
	if topic == "" {
		return nil
	}
	return r.Events.Publish(ctx, topic, payload)
}

func (r *Resolver) subscribe(ctx context.Context, entity, event string) (<-chan EventMessage, error) {
	if r.Events == nil {
		return nil, errors.New("subscriptions are not configured")
	}
	topic := subscriptionTopic(entity, event)
	if topic == "" {
		return nil, errors.New("subscription is not enabled for " + entity + ":" + event)
	}
	return r.Events.Subscribe(ctx, topic)
}

func (r *Resolver) loader(ctx context.Context) *dataloader.Loader {
	if r.Loaders != nil {
		return r.Loaders
	}
	if ctx == nil {
		return nil
	}
	loader, _ := dataloader.FromContext(ctx)
	return loader
}

func buildCriteria(entity string, p *model.PaginationInput, order []*model.OrderByInput, filters []*model.FilterInput) []repository.SelectCriteria {
	fields := criteriaConfig[entity]
	criteria := make([]repository.SelectCriteria, 0, 1+len(order)+len(filters))

	if p != nil {
		if p.Limit != nil && *p.Limit > 0 {
			limit := *p.Limit
			criteria = append(criteria, func(q *bun.SelectQuery) *bun.SelectQuery {
				return q.Limit(limit)
			})
		}
		if p.Offset != nil && *p.Offset >= 0 {
			offset := *p.Offset
			criteria = append(criteria, func(q *bun.SelectQuery) *bun.SelectQuery {
				return q.Offset(offset)
			})
		}
	}

	for _, ob := range order {
		if ob == nil || ob.Field == "" {
			continue
		}
		field, ok := lookupField(fields, ob.Field)
		if !ok {
			continue
		}

		dir := normalizeDirection(ob.Direction)
		column := field.Column
		relation := findOriginalNameForJoinKey(entity, ob.Field)
		relType := field.RelationType

		criteria = append(criteria, func(q *bun.SelectQuery) *bun.SelectQuery {
			var col string
			q, col = applyRelation(q, relation, relType, field, column)
			if col == "" {
				col = column
			}
			return q.OrderExpr("? ?", bun.Safe(col), bun.Safe(dir))
		})
	}

	for _, filter := range filters {
		if filter == nil || filter.Field == "" {
			continue
		}
		field, ok := lookupField(fields, filter.Field)
		if !ok {
			continue
		}

		op := normalizeOperator(filter.Operator)
		if op == "" {
			continue
		}

		value := strings.TrimSpace(filter.Value)
		if value == "" {
			continue
		}

		column := field.Column
		relation := findOriginalNameForJoinKey(entity, filter.Field)
		relType := field.RelationType

		switch op {
		case "IN", "NOT IN":
			values := splitList(value)
			if len(values) == 0 {
				continue
			}
			criteria = append(criteria, func(q *bun.SelectQuery) *bun.SelectQuery {
				var col string
				q, col = applyRelation(q, relation, relType, field, column)
				if col == "" {
					col = column
				}
				expr := fmt.Sprintf("%s IN (?)", col)
				if op == "NOT IN" {
					expr = fmt.Sprintf("%s NOT IN (?)", col)
				}
				return q.Where(expr, bun.In(values))
			})
		default:
			criteria = append(criteria, func(q *bun.SelectQuery) *bun.SelectQuery {
				var col string
				q, col = applyRelation(q, relation, relType, field, column)
				if col == "" {
					col = column
				}
				return q.Where(fmt.Sprintf("%s %s ?", col, op), value)
			})
		}
	}

	return criteria
}

func applyRelation(q *bun.SelectQuery, relation, relType string, field criteriaField, column string) (*bun.SelectQuery, string) {
	rel := strings.ToLower(strings.ReplaceAll(relType, "-", ""))
	rel = strings.ReplaceAll(rel, "_", "")
	if (rel == "manytomany" || rel == "m2m") && field.PivotTable != "" && field.SourcePivot != "" && field.TargetPivot != "" && field.TargetTable != "" {
		targetAlias := strings.ToLower(strings.ReplaceAll(field.Relation, ".", "_"))
		pivotAlias := fmt.Sprintf("%s_pivot", targetAlias)
		q = q.Join(fmt.Sprintf("JOIN %s AS %s ON %s.%s = ?TableAlias.%s", field.PivotTable, pivotAlias, pivotAlias, field.SourcePivot, field.SourceColumn))
		q = q.Join(fmt.Sprintf("JOIN %s AS %s ON %s.%s = %s.%s", field.TargetTable, targetAlias, targetAlias, field.TargetColumn, pivotAlias, field.TargetPivot))
		if strings.Contains(column, ".") {
			parts := strings.SplitN(column, ".", 2)
			column = targetAlias + "." + parts[1]
		} else {
			column = targetAlias + "." + column
		}
		return q, column
	}
	if relation != "" {
		q = q.Relation(relation)
	}
	return q, column
}

func paginationBounds(p *model.PaginationInput, returned int) (limit int, offset int) {
	if p != nil {
		if p.Limit != nil && *p.Limit > 0 {
			limit = *p.Limit
		}
		if p.Offset != nil && *p.Offset > 0 {
			offset = *p.Offset
		}
	}
	if limit <= 0 {
		limit = returned
	}
	return limit, offset
}

func buildPageInfoMeta(offset, count, limit, total int) *model.PageInfo {
	if limit < 0 {
		limit = 0
	}
	if count < 0 {
		count = 0
	}

	hasNext := offset+count < total
	if limit > 0 {
		hasNext = offset+limit < total
	}

	var startCursor, endCursor string
	if count > 0 {
		startCursor = encodeCursor(offset)
		endCursor = encodeCursor(offset + count - 1)
	}

	return &model.PageInfo{
		Total:           total,
		HasNextPage:     hasNext,
		HasPreviousPage: offset > 0,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}
}

func encodeCursor(offset int) string {
	if offset < 0 {
		offset = 0
	}
	return base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("cursor:%d", offset)))
}

func normalizeDirection(dir *model.OrderDirection) string {
	if dir == nil {
		return "ASC"
	}
	value := strings.ToUpper(string(*dir))
	if value != "DESC" {
		return "ASC"
	}
	return value
}

func normalizeOperator(op model.FilterOperator) string {
	switch strings.ToUpper(string(op)) {
	case "EQ":
		return "="
	case "NE":
		return "<>"
	case "GT":
		return ">"
	case "LT":
		return "<"
	case "GTE":
		return ">="
	case "LTE":
		return "<="
	case "ILIKE":
		return "ILIKE"
	case "LIKE":
		return "LIKE"
	case "IN":
		return "IN"
	case "NOT_IN":
		return "NOT IN"
	default:
		return ""
	}
}

func lookupField(fields map[string]criteriaField, raw string) (criteriaField, bool) {
	if len(fields) == 0 {
		return criteriaField{}, false
	}
	key := strings.ToLower(strings.TrimSpace(raw))
	value, ok := fields[key]
	return value, ok
}

func splitList(raw string) []string {
	if strings.TrimSpace(raw) == "" {
		return nil
	}
	parts := strings.Split(raw, ",")
	out := make([]string, 0, len(parts))
	for _, part := range parts {
		val := strings.TrimSpace(part)
		if val == "" {
			continue
		}
		out = append(out, val)
	}
	return out
}

func applyInput[T any, I any](dst *T, src I) {
	if dst == nil {
		return
	}

	dv := reflect.ValueOf(dst)
	if dv.Kind() != reflect.Pointer || dv.IsNil() {
		return
	}

	sv := reflect.ValueOf(src)
	if sv.Kind() == reflect.Pointer {
		if sv.IsNil() {
			return
		}
		sv = sv.Elem()
	}

	dv = dv.Elem()

	for i := 0; i < sv.NumField(); i++ {
		sf := sv.Field(i)
		df := dv.FieldByName(sv.Type().Field(i).Name)
		if !df.IsValid() || !df.CanSet() {
			continue
		}
		if sf.Kind() == reflect.Pointer {
			if sf.IsNil() {
				continue
			}
			sf = sf.Elem()
		}
		assignField(df, sf)
	}
}

func assignField(dst, src reflect.Value) {
	switch {
	case !dst.IsValid() || !dst.CanSet():
		return
	case src.Type().AssignableTo(dst.Type()):
		dst.Set(src)
	case dst.Kind() == reflect.Pointer && src.Type().AssignableTo(dst.Type().Elem()):
		if dst.IsNil() {
			dst.Set(reflect.New(dst.Type().Elem()))
		}
		dst.Elem().Set(src)
	case src.Type().ConvertibleTo(dst.Type()):
		dst.Set(src.Convert(dst.Type()))
	case dst.Kind() == reflect.Pointer && src.Type().ConvertibleTo(dst.Type().Elem()):
		if dst.IsNil() {
			dst.Set(reflect.New(dst.Type().Elem()))
		}
		dst.Elem().Set(src.Convert(dst.Type().Elem()))
	}
}

func setID[T any](dst *T, id string) {
	dv := reflect.ValueOf(dst).Elem()
	for _, name := range []string{"ID", "Id"} {
		f := dv.FieldByName(name)
		if f.IsValid() && f.CanSet() && f.Kind() == reflect.String {
			f.SetString(id)
			return
		}
	}
}

func asUUID(id string) model.UUID { return model.UUID(id) }

func asTime(t *time.Time) *model.Time {
	if t == nil {
		return nil
	}
	val := model.Time(*t)
	return &val
}

func setUUID(dst *string, data model.UUID) {
	*dst = string(data)
}

func setUUIDPtr(dst **string, data *model.UUID) {
	if data == nil {
		*dst = nil
		return
	}
	val := string(*data)
	*dst = &val
}

func setTimePtr(dst **time.Time, data *model.Time) {
	if data == nil {
		*dst = nil
		return
	}
	val := time.Time(*data)
	*dst = &val
}

func valueString(v any) string {
	switch val := v.(type) {
	case nil:
		return ""
	case *string:
		if val == nil {
			return ""
		}
		return *val
	case fmt.Stringer:
		return val.String()
	default:
		return fmt.Sprint(val)
	}
}

func (r *Resolver) AuthorService() crud.Service[model.Author] {
	if r.AuthorSvc == nil {
		panic("AuthorService is not configured on Resolver")
	}
	return r.AuthorSvc
}

func (r *Resolver) GetAuthor(ctx context.Context, id string) (*model.Author, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Author", "show"); err != nil {
		return nil, err
	}
	svc := r.AuthorService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListAuthor(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) (*model.AuthorConnection, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Author", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria("Author", pagination, orderBy, filter)
	svc := r.AuthorService()
	records, total, err := svc.Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	limit, offset := paginationBounds(pagination, len(records))
	result := make([]*model.Author, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	edges := make([]*model.AuthorEdge, 0, len(result))
	for i := range result {
		edges = append(edges, &model.AuthorEdge{
			Cursor: encodeCursor(offset + i),
			Node:   result[i],
		})
	}
	return &model.AuthorConnection{
		Edges:    edges,
		PageInfo: buildPageInfoMeta(offset, len(result), limit, total),
	}, nil
}

func (r *Resolver) CreateAuthor(ctx context.Context, input model.CreateAuthorInput) (*model.Author, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Author", "create"); err != nil {
		return nil, err
	}
	var record model.Author
	applyInput(&record, input)
	svc := r.AuthorService()
	record, err := svc.Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "Author", "created", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateAuthor(ctx context.Context, id string, input model.UpdateAuthorInput) (*model.Author, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Author", "update"); err != nil {
		return nil, err
	}
	svc := r.AuthorService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	setID(&record, id)
	applyInput(&record, input)
	record, err = svc.Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "Author", "updated", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteAuthor(ctx context.Context, id string) (bool, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return false, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Author", "delete"); err != nil {
		return false, err
	}
	svc := r.AuthorService()
	var record model.Author
	setID(&record, id)
	var deleted *model.Author
	if hasSubscription("Author", "deleted") && r.Events != nil {
		current, err := svc.Show(r.crudContext(ctx), id, nil)
		if err == nil {
			deleted = &current
		}
	}
	if err := svc.Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	payload := record
	if deleted != nil {
		payload = *deleted
	}
	if err := r.publishEvent(ctx, "Author", "deleted", payload); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) AuthorProfileService() crud.Service[model.AuthorProfile] {
	if r.AuthorProfileSvc == nil {
		panic("AuthorProfileService is not configured on Resolver")
	}
	return r.AuthorProfileSvc
}

func (r *Resolver) GetAuthorProfile(ctx context.Context, id string) (*model.AuthorProfile, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "AuthorProfile", "show"); err != nil {
		return nil, err
	}
	svc := r.AuthorProfileService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListAuthorProfile(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) (*model.AuthorProfileConnection, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "AuthorProfile", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria("AuthorProfile", pagination, orderBy, filter)
	svc := r.AuthorProfileService()
	records, total, err := svc.Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	limit, offset := paginationBounds(pagination, len(records))
	result := make([]*model.AuthorProfile, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	edges := make([]*model.AuthorProfileEdge, 0, len(result))
	for i := range result {
		edges = append(edges, &model.AuthorProfileEdge{
			Cursor: encodeCursor(offset + i),
			Node:   result[i],
		})
	}
	return &model.AuthorProfileConnection{
		Edges:    edges,
		PageInfo: buildPageInfoMeta(offset, len(result), limit, total),
	}, nil
}

func (r *Resolver) CreateAuthorProfile(ctx context.Context, input model.CreateAuthorProfileInput) (*model.AuthorProfile, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "AuthorProfile", "create"); err != nil {
		return nil, err
	}
	var record model.AuthorProfile
	applyInput(&record, input)
	svc := r.AuthorProfileService()
	record, err := svc.Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "AuthorProfile", "created", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateAuthorProfile(ctx context.Context, id string, input model.UpdateAuthorProfileInput) (*model.AuthorProfile, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "AuthorProfile", "update"); err != nil {
		return nil, err
	}
	svc := r.AuthorProfileService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	setID(&record, id)
	applyInput(&record, input)
	record, err = svc.Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "AuthorProfile", "updated", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteAuthorProfile(ctx context.Context, id string) (bool, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return false, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "AuthorProfile", "delete"); err != nil {
		return false, err
	}
	svc := r.AuthorProfileService()
	var record model.AuthorProfile
	setID(&record, id)
	var deleted *model.AuthorProfile
	if hasSubscription("AuthorProfile", "deleted") && r.Events != nil {
		current, err := svc.Show(r.crudContext(ctx), id, nil)
		if err == nil {
			deleted = &current
		}
	}
	if err := svc.Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	payload := record
	if deleted != nil {
		payload = *deleted
	}
	if err := r.publishEvent(ctx, "AuthorProfile", "deleted", payload); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) BookService() crud.Service[model.Book] {
	if r.BookSvc == nil {
		panic("BookService is not configured on Resolver")
	}
	return r.BookSvc
}

func (r *Resolver) GetBook(ctx context.Context, id string) (*model.Book, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Book", "show"); err != nil {
		return nil, err
	}
	svc := r.BookService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListBook(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) (*model.BookConnection, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Book", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria("Book", pagination, orderBy, filter)
	svc := r.BookService()
	records, total, err := svc.Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	limit, offset := paginationBounds(pagination, len(records))
	result := make([]*model.Book, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	edges := make([]*model.BookEdge, 0, len(result))
	for i := range result {
		edges = append(edges, &model.BookEdge{
			Cursor: encodeCursor(offset + i),
			Node:   result[i],
		})
	}
	return &model.BookConnection{
		Edges:    edges,
		PageInfo: buildPageInfoMeta(offset, len(result), limit, total),
	}, nil
}

func (r *Resolver) CreateBook(ctx context.Context, input model.CreateBookInput) (*model.Book, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Book", "create"); err != nil {
		return nil, err
	}
	var record model.Book
	applyInput(&record, input)
	svc := r.BookService()
	record, err := svc.Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "Book", "created", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateBook(ctx context.Context, id string, input model.UpdateBookInput) (*model.Book, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Book", "update"); err != nil {
		return nil, err
	}
	svc := r.BookService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	setID(&record, id)
	applyInput(&record, input)
	record, err = svc.Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "Book", "updated", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteBook(ctx context.Context, id string) (bool, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return false, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Book", "delete"); err != nil {
		return false, err
	}
	svc := r.BookService()
	var record model.Book
	setID(&record, id)
	var deleted *model.Book
	if hasSubscription("Book", "deleted") && r.Events != nil {
		current, err := svc.Show(r.crudContext(ctx), id, nil)
		if err == nil {
			deleted = &current
		}
	}
	if err := svc.Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	payload := record
	if deleted != nil {
		payload = *deleted
	}
	if err := r.publishEvent(ctx, "Book", "deleted", payload); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) ChapterService() crud.Service[model.Chapter] {
	if r.ChapterSvc == nil {
		panic("ChapterService is not configured on Resolver")
	}
	return r.ChapterSvc
}

func (r *Resolver) GetChapter(ctx context.Context, id string) (*model.Chapter, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Chapter", "show"); err != nil {
		return nil, err
	}
	svc := r.ChapterService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListChapter(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) (*model.ChapterConnection, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Chapter", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria("Chapter", pagination, orderBy, filter)
	svc := r.ChapterService()
	records, total, err := svc.Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	limit, offset := paginationBounds(pagination, len(records))
	result := make([]*model.Chapter, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	edges := make([]*model.ChapterEdge, 0, len(result))
	for i := range result {
		edges = append(edges, &model.ChapterEdge{
			Cursor: encodeCursor(offset + i),
			Node:   result[i],
		})
	}
	return &model.ChapterConnection{
		Edges:    edges,
		PageInfo: buildPageInfoMeta(offset, len(result), limit, total),
	}, nil
}

func (r *Resolver) CreateChapter(ctx context.Context, input model.CreateChapterInput) (*model.Chapter, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Chapter", "create"); err != nil {
		return nil, err
	}
	var record model.Chapter
	applyInput(&record, input)
	svc := r.ChapterService()
	record, err := svc.Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "Chapter", "created", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateChapter(ctx context.Context, id string, input model.UpdateChapterInput) (*model.Chapter, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Chapter", "update"); err != nil {
		return nil, err
	}
	svc := r.ChapterService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	setID(&record, id)
	applyInput(&record, input)
	record, err = svc.Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "Chapter", "updated", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteChapter(ctx context.Context, id string) (bool, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return false, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Chapter", "delete"); err != nil {
		return false, err
	}
	svc := r.ChapterService()
	var record model.Chapter
	setID(&record, id)
	var deleted *model.Chapter
	if hasSubscription("Chapter", "deleted") && r.Events != nil {
		current, err := svc.Show(r.crudContext(ctx), id, nil)
		if err == nil {
			deleted = &current
		}
	}
	if err := svc.Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	payload := record
	if deleted != nil {
		payload = *deleted
	}
	if err := r.publishEvent(ctx, "Chapter", "deleted", payload); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) HeadquartersService() crud.Service[model.Headquarters] {
	if r.HeadquartersSvc == nil {
		panic("HeadquartersService is not configured on Resolver")
	}
	return r.HeadquartersSvc
}

func (r *Resolver) GetHeadquarters(ctx context.Context, id string) (*model.Headquarters, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Headquarters", "show"); err != nil {
		return nil, err
	}
	svc := r.HeadquartersService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListHeadquarters(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) (*model.HeadquartersConnection, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Headquarters", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria("Headquarters", pagination, orderBy, filter)
	svc := r.HeadquartersService()
	records, total, err := svc.Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	limit, offset := paginationBounds(pagination, len(records))
	result := make([]*model.Headquarters, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	edges := make([]*model.HeadquartersEdge, 0, len(result))
	for i := range result {
		edges = append(edges, &model.HeadquartersEdge{
			Cursor: encodeCursor(offset + i),
			Node:   result[i],
		})
	}
	return &model.HeadquartersConnection{
		Edges:    edges,
		PageInfo: buildPageInfoMeta(offset, len(result), limit, total),
	}, nil
}

func (r *Resolver) CreateHeadquarters(ctx context.Context, input model.CreateHeadquartersInput) (*model.Headquarters, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Headquarters", "create"); err != nil {
		return nil, err
	}
	var record model.Headquarters
	applyInput(&record, input)
	svc := r.HeadquartersService()
	record, err := svc.Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "Headquarters", "created", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateHeadquarters(ctx context.Context, id string, input model.UpdateHeadquartersInput) (*model.Headquarters, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Headquarters", "update"); err != nil {
		return nil, err
	}
	svc := r.HeadquartersService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	setID(&record, id)
	applyInput(&record, input)
	record, err = svc.Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "Headquarters", "updated", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteHeadquarters(ctx context.Context, id string) (bool, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return false, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Headquarters", "delete"); err != nil {
		return false, err
	}
	svc := r.HeadquartersService()
	var record model.Headquarters
	setID(&record, id)
	var deleted *model.Headquarters
	if hasSubscription("Headquarters", "deleted") && r.Events != nil {
		current, err := svc.Show(r.crudContext(ctx), id, nil)
		if err == nil {
			deleted = &current
		}
	}
	if err := svc.Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	payload := record
	if deleted != nil {
		payload = *deleted
	}
	if err := r.publishEvent(ctx, "Headquarters", "deleted", payload); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) PublishingHouseService() crud.Service[model.PublishingHouse] {
	if r.PublishingHouseSvc == nil {
		panic("PublishingHouseService is not configured on Resolver")
	}
	return r.PublishingHouseSvc
}

func (r *Resolver) GetPublishingHouse(ctx context.Context, id string) (*model.PublishingHouse, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "PublishingHouse", "show"); err != nil {
		return nil, err
	}
	svc := r.PublishingHouseService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListPublishingHouse(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) (*model.PublishingHouseConnection, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "PublishingHouse", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria("PublishingHouse", pagination, orderBy, filter)
	svc := r.PublishingHouseService()
	records, total, err := svc.Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	limit, offset := paginationBounds(pagination, len(records))
	result := make([]*model.PublishingHouse, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	edges := make([]*model.PublishingHouseEdge, 0, len(result))
	for i := range result {
		edges = append(edges, &model.PublishingHouseEdge{
			Cursor: encodeCursor(offset + i),
			Node:   result[i],
		})
	}
	return &model.PublishingHouseConnection{
		Edges:    edges,
		PageInfo: buildPageInfoMeta(offset, len(result), limit, total),
	}, nil
}

func (r *Resolver) CreatePublishingHouse(ctx context.Context, input model.CreatePublishingHouseInput) (*model.PublishingHouse, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "PublishingHouse", "create"); err != nil {
		return nil, err
	}
	var record model.PublishingHouse
	applyInput(&record, input)
	svc := r.PublishingHouseService()
	record, err := svc.Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "PublishingHouse", "created", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdatePublishingHouse(ctx context.Context, id string, input model.UpdatePublishingHouseInput) (*model.PublishingHouse, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "PublishingHouse", "update"); err != nil {
		return nil, err
	}
	svc := r.PublishingHouseService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	setID(&record, id)
	applyInput(&record, input)
	record, err = svc.Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "PublishingHouse", "updated", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeletePublishingHouse(ctx context.Context, id string) (bool, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return false, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "PublishingHouse", "delete"); err != nil {
		return false, err
	}
	svc := r.PublishingHouseService()
	var record model.PublishingHouse
	setID(&record, id)
	var deleted *model.PublishingHouse
	if hasSubscription("PublishingHouse", "deleted") && r.Events != nil {
		current, err := svc.Show(r.crudContext(ctx), id, nil)
		if err == nil {
			deleted = &current
		}
	}
	if err := svc.Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	payload := record
	if deleted != nil {
		payload = *deleted
	}
	if err := r.publishEvent(ctx, "PublishingHouse", "deleted", payload); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) TagService() crud.Service[model.Tag] {
	if r.TagSvc == nil {
		panic("TagService is not configured on Resolver")
	}
	return r.TagSvc
}

func (r *Resolver) GetTag(ctx context.Context, id string) (*model.Tag, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Tag", "show"); err != nil {
		return nil, err
	}
	svc := r.TagService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) ListTag(ctx context.Context, pagination *model.PaginationInput, orderBy []*model.OrderByInput, filter []*model.FilterInput) (*model.TagConnection, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Tag", "index"); err != nil {
		return nil, err
	}
	criteria := buildCriteria("Tag", pagination, orderBy, filter)
	svc := r.TagService()
	records, total, err := svc.Index(r.crudContext(ctx), criteria)
	if err != nil {
		return nil, err
	}
	limit, offset := paginationBounds(pagination, len(records))
	result := make([]*model.Tag, 0, len(records))
	for i := range records {
		result = append(result, &records[i])
	}
	edges := make([]*model.TagEdge, 0, len(result))
	for i := range result {
		edges = append(edges, &model.TagEdge{
			Cursor: encodeCursor(offset + i),
			Node:   result[i],
		})
	}
	return &model.TagConnection{
		Edges:    edges,
		PageInfo: buildPageInfoMeta(offset, len(result), limit, total),
	}, nil
}

func (r *Resolver) CreateTag(ctx context.Context, input model.CreateTagInput) (*model.Tag, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Tag", "create"); err != nil {
		return nil, err
	}
	var record model.Tag
	applyInput(&record, input)
	svc := r.TagService()
	record, err := svc.Create(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "Tag", "created", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) UpdateTag(ctx context.Context, id string, input model.UpdateTagInput) (*model.Tag, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return nil, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Tag", "update"); err != nil {
		return nil, err
	}
	svc := r.TagService()
	record, err := svc.Show(r.crudContext(ctx), id, nil)
	if err != nil {
		return nil, err
	}
	setID(&record, id)
	applyInput(&record, input)
	record, err = svc.Update(r.crudContext(ctx), record)
	if err != nil {
		return nil, err
	}
	if err := r.publishEvent(ctx, "Tag", "updated", record); err != nil {
		return nil, err
	}
	return &record, nil
}

func (r *Resolver) DeleteTag(ctx context.Context, id string) (bool, error) {
	user, ok := auth.FromContext(ctx)
	if !ok || user == nil {
		return false, errors.New("unauthorized")
	}
	_ = user
	if err := r.guard(ctx, "Tag", "delete"); err != nil {
		return false, err
	}
	svc := r.TagService()
	var record model.Tag
	setID(&record, id)
	var deleted *model.Tag
	if hasSubscription("Tag", "deleted") && r.Events != nil {
		current, err := svc.Show(r.crudContext(ctx), id, nil)
		if err == nil {
			deleted = &current
		}
	}
	if err := svc.Delete(r.crudContext(ctx), record); err != nil {
		return false, err
	}
	payload := record
	if deleted != nil {
		payload = *deleted
	}
	if err := r.publishEvent(ctx, "Tag", "deleted", payload); err != nil {
		return false, err
	}
	return true, nil
}

func (r *Resolver) AuthorCreated(ctx context.Context) (<-chan *model.Author, error) {
	stream, err := r.subscribe(ctx, "Author", "created")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Author)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Author:
					out <- payload
				case model.Author:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) AuthorUpdated(ctx context.Context) (<-chan *model.Author, error) {
	stream, err := r.subscribe(ctx, "Author", "updated")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Author)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Author:
					out <- payload
				case model.Author:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) AuthorDeleted(ctx context.Context) (<-chan *model.Author, error) {
	stream, err := r.subscribe(ctx, "Author", "deleted")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Author)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Author:
					out <- payload
				case model.Author:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) AuthorProfileCreated(ctx context.Context) (<-chan *model.AuthorProfile, error) {
	stream, err := r.subscribe(ctx, "AuthorProfile", "created")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.AuthorProfile)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.AuthorProfile:
					out <- payload
				case model.AuthorProfile:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) AuthorProfileUpdated(ctx context.Context) (<-chan *model.AuthorProfile, error) {
	stream, err := r.subscribe(ctx, "AuthorProfile", "updated")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.AuthorProfile)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.AuthorProfile:
					out <- payload
				case model.AuthorProfile:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) AuthorProfileDeleted(ctx context.Context) (<-chan *model.AuthorProfile, error) {
	stream, err := r.subscribe(ctx, "AuthorProfile", "deleted")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.AuthorProfile)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.AuthorProfile:
					out <- payload
				case model.AuthorProfile:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) BookCreated(ctx context.Context) (<-chan *model.Book, error) {
	stream, err := r.subscribe(ctx, "Book", "created")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Book)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Book:
					out <- payload
				case model.Book:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) BookUpdated(ctx context.Context) (<-chan *model.Book, error) {
	stream, err := r.subscribe(ctx, "Book", "updated")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Book)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Book:
					out <- payload
				case model.Book:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) BookDeleted(ctx context.Context) (<-chan *model.Book, error) {
	stream, err := r.subscribe(ctx, "Book", "deleted")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Book)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Book:
					out <- payload
				case model.Book:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) ChapterCreated(ctx context.Context) (<-chan *model.Chapter, error) {
	stream, err := r.subscribe(ctx, "Chapter", "created")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Chapter)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Chapter:
					out <- payload
				case model.Chapter:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) ChapterUpdated(ctx context.Context) (<-chan *model.Chapter, error) {
	stream, err := r.subscribe(ctx, "Chapter", "updated")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Chapter)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Chapter:
					out <- payload
				case model.Chapter:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) ChapterDeleted(ctx context.Context) (<-chan *model.Chapter, error) {
	stream, err := r.subscribe(ctx, "Chapter", "deleted")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Chapter)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Chapter:
					out <- payload
				case model.Chapter:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) HeadquartersCreated(ctx context.Context) (<-chan *model.Headquarters, error) {
	stream, err := r.subscribe(ctx, "Headquarters", "created")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Headquarters)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Headquarters:
					out <- payload
				case model.Headquarters:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) HeadquartersUpdated(ctx context.Context) (<-chan *model.Headquarters, error) {
	stream, err := r.subscribe(ctx, "Headquarters", "updated")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Headquarters)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Headquarters:
					out <- payload
				case model.Headquarters:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) HeadquartersDeleted(ctx context.Context) (<-chan *model.Headquarters, error) {
	stream, err := r.subscribe(ctx, "Headquarters", "deleted")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Headquarters)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Headquarters:
					out <- payload
				case model.Headquarters:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) PublishingHouseCreated(ctx context.Context) (<-chan *model.PublishingHouse, error) {
	stream, err := r.subscribe(ctx, "PublishingHouse", "created")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.PublishingHouse)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.PublishingHouse:
					out <- payload
				case model.PublishingHouse:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) PublishingHouseUpdated(ctx context.Context) (<-chan *model.PublishingHouse, error) {
	stream, err := r.subscribe(ctx, "PublishingHouse", "updated")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.PublishingHouse)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.PublishingHouse:
					out <- payload
				case model.PublishingHouse:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) PublishingHouseDeleted(ctx context.Context) (<-chan *model.PublishingHouse, error) {
	stream, err := r.subscribe(ctx, "PublishingHouse", "deleted")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.PublishingHouse)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.PublishingHouse:
					out <- payload
				case model.PublishingHouse:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) TagCreated(ctx context.Context) (<-chan *model.Tag, error) {
	stream, err := r.subscribe(ctx, "Tag", "created")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Tag)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Tag:
					out <- payload
				case model.Tag:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) TagUpdated(ctx context.Context) (<-chan *model.Tag, error) {
	stream, err := r.subscribe(ctx, "Tag", "updated")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Tag)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Tag:
					out <- payload
				case model.Tag:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *Resolver) TagDeleted(ctx context.Context) (<-chan *model.Tag, error) {
	stream, err := r.subscribe(ctx, "Tag", "deleted")
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Tag)
	go func() {
		defer close(out)
		for {
			select {
			case <-ctx.Done():
				return
			case msg, ok := <-stream:
				if !ok {
					return
				}
				if msg.Err != nil {
					continue
				}
				switch payload := msg.Payload.(type) {
				case *model.Tag:
					out <- payload
				case model.Tag:
					item := payload
					out <- &item
				}
			}
		}
	}()

	return out, nil
}

func (r *authorResolver) Books(ctx context.Context, obj *model.Author) ([]*model.Book, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Books != nil && len(obj.Books) > 0 {
		return obj.Books, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Books, nil
	}
	key := valueString(obj.Id)
	if strings.TrimSpace(key) == "" {
		return obj.Books, nil
	}
	items, err := loader.AuthorBooks.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return items, nil

}

func (r *authorResolver) Profile(ctx context.Context, obj *model.Author) (*model.AuthorProfile, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Profile != nil {
		return obj.Profile, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Profile, nil
	}
	key := valueString(obj.Id)
	if strings.TrimSpace(key) == "" {
		return obj.Profile, nil
	}
	items, err := loader.AuthorProfile.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	if len(items) > 0 {
		return items[0], nil
	}
	return nil, nil

}

func (r *authorResolver) Publisher(ctx context.Context, obj *model.Author) (*model.PublishingHouse, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Publisher != nil {
		return obj.Publisher, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Publisher, nil
	}
	key := valueString(obj.PublisherId)
	if strings.TrimSpace(key) == "" {
		return nil, nil
	}
	record, err := loader.PublishingHouseByID.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return record, nil

}

func (r *authorResolver) Tags(ctx context.Context, obj *model.Author) ([]*model.Tag, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Tags != nil && len(obj.Tags) > 0 {
		return obj.Tags, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Tags, nil
	}
	key := valueString(obj.Id)
	if strings.TrimSpace(key) == "" {
		return obj.Tags, nil
	}
	items, err := loader.AuthorTags.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return items, nil

}

func (r *authorProfileResolver) Author(ctx context.Context, obj *model.AuthorProfile) (*model.Author, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Author != nil {
		return obj.Author, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Author, nil
	}
	key := valueString(obj.AuthorId)
	if strings.TrimSpace(key) == "" {
		return nil, nil
	}
	record, err := loader.AuthorByID.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return record, nil

}

func (r *bookResolver) Author(ctx context.Context, obj *model.Book) (*model.Author, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Author != nil {
		return obj.Author, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Author, nil
	}
	key := valueString(obj.AuthorId)
	if strings.TrimSpace(key) == "" {
		return nil, nil
	}
	record, err := loader.AuthorByID.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return record, nil

}

func (r *bookResolver) Chapters(ctx context.Context, obj *model.Book) ([]*model.Chapter, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Chapters != nil && len(obj.Chapters) > 0 {
		return obj.Chapters, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Chapters, nil
	}
	key := valueString(obj.Id)
	if strings.TrimSpace(key) == "" {
		return obj.Chapters, nil
	}
	items, err := loader.BookChapters.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return items, nil

}

func (r *bookResolver) Publisher(ctx context.Context, obj *model.Book) (*model.PublishingHouse, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Publisher != nil {
		return obj.Publisher, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Publisher, nil
	}
	key := valueString(obj.PublisherId)
	if strings.TrimSpace(key) == "" {
		return nil, nil
	}
	record, err := loader.PublishingHouseByID.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return record, nil

}

func (r *bookResolver) Tags(ctx context.Context, obj *model.Book) ([]*model.Tag, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Tags != nil && len(obj.Tags) > 0 {
		return obj.Tags, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Tags, nil
	}
	key := valueString(obj.Id)
	if strings.TrimSpace(key) == "" {
		return obj.Tags, nil
	}
	items, err := loader.BookTags.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return items, nil

}

func (r *chapterResolver) Book(ctx context.Context, obj *model.Chapter) (*model.Book, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Book != nil {
		return obj.Book, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Book, nil
	}
	key := valueString(obj.BookId)
	if strings.TrimSpace(key) == "" {
		return nil, nil
	}
	record, err := loader.BookByID.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return record, nil

}

func (r *headquartersResolver) Publisher(ctx context.Context, obj *model.Headquarters) (*model.PublishingHouse, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Publisher != nil {
		return obj.Publisher, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Publisher, nil
	}
	key := valueString(obj.PublisherId)
	if strings.TrimSpace(key) == "" {
		return nil, nil
	}
	record, err := loader.PublishingHouseByID.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return record, nil

}

func (r *publishingHouseResolver) Authors(ctx context.Context, obj *model.PublishingHouse) ([]*model.Author, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Authors != nil && len(obj.Authors) > 0 {
		return obj.Authors, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Authors, nil
	}
	key := valueString(obj.Id)
	if strings.TrimSpace(key) == "" {
		return obj.Authors, nil
	}
	items, err := loader.PublishingHouseAuthors.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return items, nil

}

func (r *publishingHouseResolver) Books(ctx context.Context, obj *model.PublishingHouse) ([]*model.Book, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Books != nil && len(obj.Books) > 0 {
		return obj.Books, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Books, nil
	}
	key := valueString(obj.Id)
	if strings.TrimSpace(key) == "" {
		return obj.Books, nil
	}
	items, err := loader.PublishingHouseBooks.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return items, nil

}

func (r *publishingHouseResolver) Headquarters(ctx context.Context, obj *model.PublishingHouse) (*model.Headquarters, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Headquarters != nil {
		return obj.Headquarters, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Headquarters, nil
	}
	key := valueString(obj.Id)
	if strings.TrimSpace(key) == "" {
		return obj.Headquarters, nil
	}
	items, err := loader.PublishingHouseHeadquarters.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	if len(items) > 0 {
		return items[0], nil
	}
	return nil, nil

}

func (r *tagResolver) Authors(ctx context.Context, obj *model.Tag) ([]*model.Author, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Authors != nil && len(obj.Authors) > 0 {
		return obj.Authors, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Authors, nil
	}
	key := valueString(obj.Id)
	if strings.TrimSpace(key) == "" {
		return obj.Authors, nil
	}
	items, err := loader.TagAuthors.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return items, nil

}

func (r *tagResolver) Books(ctx context.Context, obj *model.Tag) ([]*model.Book, error) {
	if obj == nil {
		return nil, nil
	}
	if obj.Books != nil && len(obj.Books) > 0 {
		return obj.Books, nil
	}
	loader := r.loader(ctx)
	if loader == nil {
		return obj.Books, nil
	}
	key := valueString(obj.Id)
	if strings.TrimSpace(key) == "" {
		return obj.Books, nil
	}
	items, err := loader.TagBooks.Load(ctx, key)
	if err != nil {
		return nil, err
	}
	return items, nil

}
