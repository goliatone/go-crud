package dataloader

// Code generated by graphqlgen. DO NOT EDIT.

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"sync"

	"github.com/goliatone/go-crud"
	repository "github.com/goliatone/go-repository-bun"
	"github.com/uptrace/bun"

	"github.com/goliatone/go-crud/examples/relationships-gql/graph/model"
)

type contextKey struct{}

// Services bundles the CRUD services used by dataloaders.
type Services struct {
	Author          crud.Service[model.Author]
	AuthorProfile   crud.Service[model.AuthorProfile]
	Book            crud.Service[model.Book]
	Chapter         crud.Service[model.Chapter]
	Headquarters    crud.Service[model.Headquarters]
	PublishingHouse crud.Service[model.PublishingHouse]
	Tag             crud.Service[model.Tag]
}

// Option configures a Loader.
type Option func(*Loader)

// WithDB provides a bun database or transaction for pivot-aware joins.
func WithDB(db bun.IDB) Option {
	return func(l *Loader) {
		l.db = db
	}
}

// WithContextFactory sets a factory used to build crud.Context values from request contexts.
func WithContextFactory(factory func(context.Context) crud.Context) Option {
	return func(l *Loader) {
		l.contextFactory = factory
	}
}

// Loader batches lookups to avoid N+1 database queries.
type Loader struct {
	services       Services
	db             bun.IDB
	contextFactory func(context.Context) crud.Context

	AuthorByID                  *entityLoader[model.Author]
	AuthorBooks                 *groupLoader[model.Book]
	AuthorProfile               *groupLoader[model.AuthorProfile]
	AuthorTags                  *groupLoader[model.Tag]
	AuthorProfileByID           *entityLoader[model.AuthorProfile]
	BookByID                    *entityLoader[model.Book]
	BookChapters                *groupLoader[model.Chapter]
	BookTags                    *groupLoader[model.Tag]
	ChapterByID                 *entityLoader[model.Chapter]
	HeadquartersByID            *entityLoader[model.Headquarters]
	PublishingHouseByID         *entityLoader[model.PublishingHouse]
	PublishingHouseAuthors      *groupLoader[model.Author]
	PublishingHouseBooks        *groupLoader[model.Book]
	PublishingHouseHeadquarters *groupLoader[model.Headquarters]
	TagByID                     *entityLoader[model.Tag]
	TagAuthors                  *groupLoader[model.Author]
	TagBooks                    *groupLoader[model.Book]
}

// New builds a Loader backed by the provided services.
func New(services Services, opts ...Option) *Loader {
	loader := &Loader{
		services: services,
	}
	for _, opt := range opts {
		if opt != nil {
			opt(loader)
		}
	}

	loader.AuthorByID = newEntityLoader(func(ctx context.Context, keys []string) (map[string]*model.Author, error) {
		return loader.fetchAuthorByID(ctx, loader.crudContext(ctx), loader.services.Author, "id", keys)
	})
	loader.AuthorBooks = newGroupLoader(func(ctx context.Context, keys []string) (map[string][]*model.Book, error) {
		return loader.fetchAuthorBooks(ctx, keys)
	})
	loader.AuthorProfile = newGroupLoader(func(ctx context.Context, keys []string) (map[string][]*model.AuthorProfile, error) {
		return loader.fetchAuthorProfile(ctx, keys)
	})
	loader.AuthorTags = newGroupLoader(func(ctx context.Context, keys []string) (map[string][]*model.Tag, error) {
		return loader.fetchAuthorTags(ctx, keys)
	})
	loader.AuthorProfileByID = newEntityLoader(func(ctx context.Context, keys []string) (map[string]*model.AuthorProfile, error) {
		return loader.fetchAuthorProfileByID(ctx, loader.crudContext(ctx), loader.services.AuthorProfile, "id", keys)
	})
	loader.BookByID = newEntityLoader(func(ctx context.Context, keys []string) (map[string]*model.Book, error) {
		return loader.fetchBookByID(ctx, loader.crudContext(ctx), loader.services.Book, "id", keys)
	})
	loader.BookChapters = newGroupLoader(func(ctx context.Context, keys []string) (map[string][]*model.Chapter, error) {
		return loader.fetchBookChapters(ctx, keys)
	})
	loader.BookTags = newGroupLoader(func(ctx context.Context, keys []string) (map[string][]*model.Tag, error) {
		return loader.fetchBookTags(ctx, keys)
	})
	loader.ChapterByID = newEntityLoader(func(ctx context.Context, keys []string) (map[string]*model.Chapter, error) {
		return loader.fetchChapterByID(ctx, loader.crudContext(ctx), loader.services.Chapter, "id", keys)
	})
	loader.HeadquartersByID = newEntityLoader(func(ctx context.Context, keys []string) (map[string]*model.Headquarters, error) {
		return loader.fetchHeadquartersByID(ctx, loader.crudContext(ctx), loader.services.Headquarters, "id", keys)
	})
	loader.PublishingHouseByID = newEntityLoader(func(ctx context.Context, keys []string) (map[string]*model.PublishingHouse, error) {
		return loader.fetchPublishingHouseByID(ctx, loader.crudContext(ctx), loader.services.PublishingHouse, "id", keys)
	})
	loader.PublishingHouseAuthors = newGroupLoader(func(ctx context.Context, keys []string) (map[string][]*model.Author, error) {
		return loader.fetchPublishingHouseAuthors(ctx, keys)
	})
	loader.PublishingHouseBooks = newGroupLoader(func(ctx context.Context, keys []string) (map[string][]*model.Book, error) {
		return loader.fetchPublishingHouseBooks(ctx, keys)
	})
	loader.PublishingHouseHeadquarters = newGroupLoader(func(ctx context.Context, keys []string) (map[string][]*model.Headquarters, error) {
		return loader.fetchPublishingHouseHeadquarters(ctx, keys)
	})
	loader.TagByID = newEntityLoader(func(ctx context.Context, keys []string) (map[string]*model.Tag, error) {
		return loader.fetchTagByID(ctx, loader.crudContext(ctx), loader.services.Tag, "id", keys)
	})
	loader.TagAuthors = newGroupLoader(func(ctx context.Context, keys []string) (map[string][]*model.Author, error) {
		return loader.fetchTagAuthors(ctx, keys)
	})
	loader.TagBooks = newGroupLoader(func(ctx context.Context, keys []string) (map[string][]*model.Book, error) {
		return loader.fetchTagBooks(ctx, keys)
	})
	return loader
}

// Inject stores the loader in the provided context.
func Inject(ctx context.Context, loader *Loader) context.Context {
	return context.WithValue(ctx, contextKey{}, loader)
}

// FromContext extracts a loader if one was previously injected.
func FromContext(ctx context.Context) (*Loader, bool) {
	if ctx == nil {
		return nil, false
	}
	loader, ok := ctx.Value(contextKey{}).(*Loader)
	return loader, ok
}

func (l *Loader) crudContext(ctx context.Context) crud.Context {
	if l.contextFactory != nil {
		return l.contextFactory(ctx)
	}
	return nil
}

func (l *Loader) fetchAuthorByID(ctx context.Context, crudCtx crud.Context, svc crud.Service[model.Author], column string, keys []string) (map[string]*model.Author, error) {
	result := make(map[string]*model.Author, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := svc.Index(crudCtx, []repository.SelectCriteria{
		repository.SelectColumnIn(column, dedup),
	})
	if err != nil {
		return nil, err
	}

	for i := range records {
		record := records[i]
		result[stringValue(record.Id)] = &record
	}

	return result, nil
}

func (l *Loader) fetchAuthorBooks(ctx context.Context, keys []string) (map[string][]*model.Book, error) {
	result := make(map[string][]*model.Book, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := l.services.Book.Index(l.crudContext(ctx), []repository.SelectCriteria{
		repository.SelectColumnIn("id", dedup),
	})
	if err != nil {
		return nil, err
	}

	for _, key := range dedup {
		result[key] = result[key]
	}

	for i := range records {
		record := records[i]
		group := stringValue(record.Id)
		result[group] = append(result[group], &record)
	}

	for key := range result {
		sort.SliceStable(result[key], func(i, j int) bool {
			left := result[key][i]
			right := result[key][j]
			return stringValue(left.Id) < stringValue(right.Id)
		})
	}

	return result, nil
}

func (l *Loader) fetchAuthorProfile(ctx context.Context, keys []string) (map[string][]*model.AuthorProfile, error) {
	result := make(map[string][]*model.AuthorProfile, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := l.services.AuthorProfile.Index(l.crudContext(ctx), []repository.SelectCriteria{
		repository.SelectColumnIn("id", dedup),
	})
	if err != nil {
		return nil, err
	}

	for _, key := range dedup {
		result[key] = result[key]
	}

	for i := range records {
		record := records[i]
		group := stringValue(record.Id)
		result[group] = append(result[group], &record)
	}

	for key := range result {
		sort.SliceStable(result[key], func(i, j int) bool {
			left := result[key][i]
			right := result[key][j]
			return stringValue(left.Id) < stringValue(right.Id)
		})
	}

	return result, nil
}

func (l *Loader) fetchAuthorTags(ctx context.Context, keys []string) (map[string][]*model.Tag, error) {
	result := make(map[string][]*model.Tag, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}
	if l.db == nil {
		return nil, fmt.Errorf("dataloader: db is required to load relation Author.tags")
	}

	links, err := fetchPivotLinks(ctx, l.db, "author_tags", "author_id", "tag_id", dedup)
	if err != nil {
		return nil, err
	}

	targetIDs := make([]string, 0, len(links))
	for _, link := range links {
		targetIDs = append(targetIDs, link.Target)
	}

	loaded, err := l.TagByID.LoadMany(ctx, targetIDs)
	if err != nil {
		return nil, err
	}

	for _, link := range links {
		item := loaded[link.Target]
		if item == nil {
			continue
		}
		result[link.Source] = append(result[link.Source], item)
	}

	for _, key := range dedup {
		result[key] = result[key]
	}

	for key := range result {
		sort.SliceStable(result[key], func(i, j int) bool {
			left := result[key][i]
			right := result[key][j]
			return stringValue(left.Id) < stringValue(right.Id)
		})
	}

	return result, nil
}

func (l *Loader) fetchAuthorProfileByID(ctx context.Context, crudCtx crud.Context, svc crud.Service[model.AuthorProfile], column string, keys []string) (map[string]*model.AuthorProfile, error) {
	result := make(map[string]*model.AuthorProfile, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := svc.Index(crudCtx, []repository.SelectCriteria{
		repository.SelectColumnIn(column, dedup),
	})
	if err != nil {
		return nil, err
	}

	for i := range records {
		record := records[i]
		result[stringValue(record.Id)] = &record
	}

	return result, nil
}

func (l *Loader) fetchBookByID(ctx context.Context, crudCtx crud.Context, svc crud.Service[model.Book], column string, keys []string) (map[string]*model.Book, error) {
	result := make(map[string]*model.Book, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := svc.Index(crudCtx, []repository.SelectCriteria{
		repository.SelectColumnIn(column, dedup),
	})
	if err != nil {
		return nil, err
	}

	for i := range records {
		record := records[i]
		result[stringValue(record.Id)] = &record
	}

	return result, nil
}

func (l *Loader) fetchBookChapters(ctx context.Context, keys []string) (map[string][]*model.Chapter, error) {
	result := make(map[string][]*model.Chapter, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := l.services.Chapter.Index(l.crudContext(ctx), []repository.SelectCriteria{
		repository.SelectColumnIn("id", dedup),
	})
	if err != nil {
		return nil, err
	}

	for _, key := range dedup {
		result[key] = result[key]
	}

	for i := range records {
		record := records[i]
		group := stringValue(record.Id)
		result[group] = append(result[group], &record)
	}

	for key := range result {
		sort.SliceStable(result[key], func(i, j int) bool {
			left := result[key][i]
			right := result[key][j]
			return stringValue(left.Id) < stringValue(right.Id)
		})
	}

	return result, nil
}

func (l *Loader) fetchBookTags(ctx context.Context, keys []string) (map[string][]*model.Tag, error) {
	result := make(map[string][]*model.Tag, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}
	if l.db == nil {
		return nil, fmt.Errorf("dataloader: db is required to load relation Book.tags")
	}

	links, err := fetchPivotLinks(ctx, l.db, "book_tags", "book_id", "tag_id", dedup)
	if err != nil {
		return nil, err
	}

	targetIDs := make([]string, 0, len(links))
	for _, link := range links {
		targetIDs = append(targetIDs, link.Target)
	}

	loaded, err := l.TagByID.LoadMany(ctx, targetIDs)
	if err != nil {
		return nil, err
	}

	for _, link := range links {
		item := loaded[link.Target]
		if item == nil {
			continue
		}
		result[link.Source] = append(result[link.Source], item)
	}

	for _, key := range dedup {
		result[key] = result[key]
	}

	for key := range result {
		sort.SliceStable(result[key], func(i, j int) bool {
			left := result[key][i]
			right := result[key][j]
			return stringValue(left.Id) < stringValue(right.Id)
		})
	}

	return result, nil
}

func (l *Loader) fetchChapterByID(ctx context.Context, crudCtx crud.Context, svc crud.Service[model.Chapter], column string, keys []string) (map[string]*model.Chapter, error) {
	result := make(map[string]*model.Chapter, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := svc.Index(crudCtx, []repository.SelectCriteria{
		repository.SelectColumnIn(column, dedup),
	})
	if err != nil {
		return nil, err
	}

	for i := range records {
		record := records[i]
		result[stringValue(record.Id)] = &record
	}

	return result, nil
}

func (l *Loader) fetchHeadquartersByID(ctx context.Context, crudCtx crud.Context, svc crud.Service[model.Headquarters], column string, keys []string) (map[string]*model.Headquarters, error) {
	result := make(map[string]*model.Headquarters, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := svc.Index(crudCtx, []repository.SelectCriteria{
		repository.SelectColumnIn(column, dedup),
	})
	if err != nil {
		return nil, err
	}

	for i := range records {
		record := records[i]
		result[stringValue(record.Id)] = &record
	}

	return result, nil
}

func (l *Loader) fetchPublishingHouseByID(ctx context.Context, crudCtx crud.Context, svc crud.Service[model.PublishingHouse], column string, keys []string) (map[string]*model.PublishingHouse, error) {
	result := make(map[string]*model.PublishingHouse, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := svc.Index(crudCtx, []repository.SelectCriteria{
		repository.SelectColumnIn(column, dedup),
	})
	if err != nil {
		return nil, err
	}

	for i := range records {
		record := records[i]
		result[stringValue(record.Id)] = &record
	}

	return result, nil
}

func (l *Loader) fetchPublishingHouseAuthors(ctx context.Context, keys []string) (map[string][]*model.Author, error) {
	result := make(map[string][]*model.Author, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := l.services.Author.Index(l.crudContext(ctx), []repository.SelectCriteria{
		repository.SelectColumnIn("id", dedup),
	})
	if err != nil {
		return nil, err
	}

	for _, key := range dedup {
		result[key] = result[key]
	}

	for i := range records {
		record := records[i]
		group := stringValue(record.Id)
		result[group] = append(result[group], &record)
	}

	for key := range result {
		sort.SliceStable(result[key], func(i, j int) bool {
			left := result[key][i]
			right := result[key][j]
			return stringValue(left.Id) < stringValue(right.Id)
		})
	}

	return result, nil
}

func (l *Loader) fetchPublishingHouseBooks(ctx context.Context, keys []string) (map[string][]*model.Book, error) {
	result := make(map[string][]*model.Book, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := l.services.Book.Index(l.crudContext(ctx), []repository.SelectCriteria{
		repository.SelectColumnIn("id", dedup),
	})
	if err != nil {
		return nil, err
	}

	for _, key := range dedup {
		result[key] = result[key]
	}

	for i := range records {
		record := records[i]
		group := stringValue(record.Id)
		result[group] = append(result[group], &record)
	}

	for key := range result {
		sort.SliceStable(result[key], func(i, j int) bool {
			left := result[key][i]
			right := result[key][j]
			return stringValue(left.Id) < stringValue(right.Id)
		})
	}

	return result, nil
}

func (l *Loader) fetchPublishingHouseHeadquarters(ctx context.Context, keys []string) (map[string][]*model.Headquarters, error) {
	result := make(map[string][]*model.Headquarters, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := l.services.Headquarters.Index(l.crudContext(ctx), []repository.SelectCriteria{
		repository.SelectColumnIn("id", dedup),
	})
	if err != nil {
		return nil, err
	}

	for _, key := range dedup {
		result[key] = result[key]
	}

	for i := range records {
		record := records[i]
		group := stringValue(record.Id)
		result[group] = append(result[group], &record)
	}

	for key := range result {
		sort.SliceStable(result[key], func(i, j int) bool {
			left := result[key][i]
			right := result[key][j]
			return stringValue(left.Id) < stringValue(right.Id)
		})
	}

	return result, nil
}

func (l *Loader) fetchTagByID(ctx context.Context, crudCtx crud.Context, svc crud.Service[model.Tag], column string, keys []string) (map[string]*model.Tag, error) {
	result := make(map[string]*model.Tag, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}

	records, _, err := svc.Index(crudCtx, []repository.SelectCriteria{
		repository.SelectColumnIn(column, dedup),
	})
	if err != nil {
		return nil, err
	}

	for i := range records {
		record := records[i]
		result[stringValue(record.Id)] = &record
	}

	return result, nil
}

func (l *Loader) fetchTagAuthors(ctx context.Context, keys []string) (map[string][]*model.Author, error) {
	result := make(map[string][]*model.Author, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}
	if l.db == nil {
		return nil, fmt.Errorf("dataloader: db is required to load relation Tag.authors")
	}

	links, err := fetchPivotLinks(ctx, l.db, "tag_authors", "tag_id", "author_id", dedup)
	if err != nil {
		return nil, err
	}

	targetIDs := make([]string, 0, len(links))
	for _, link := range links {
		targetIDs = append(targetIDs, link.Target)
	}

	loaded, err := l.AuthorByID.LoadMany(ctx, targetIDs)
	if err != nil {
		return nil, err
	}

	for _, link := range links {
		item := loaded[link.Target]
		if item == nil {
			continue
		}
		result[link.Source] = append(result[link.Source], item)
	}

	for _, key := range dedup {
		result[key] = result[key]
	}

	for key := range result {
		sort.SliceStable(result[key], func(i, j int) bool {
			left := result[key][i]
			right := result[key][j]
			return stringValue(left.Id) < stringValue(right.Id)
		})
	}

	return result, nil
}

func (l *Loader) fetchTagBooks(ctx context.Context, keys []string) (map[string][]*model.Book, error) {
	result := make(map[string][]*model.Book, len(keys))
	dedup := uniqueKeys(keys)
	if len(dedup) == 0 {
		return result, nil
	}
	if l.db == nil {
		return nil, fmt.Errorf("dataloader: db is required to load relation Tag.books")
	}

	links, err := fetchPivotLinks(ctx, l.db, "tag_books", "tag_id", "book_id", dedup)
	if err != nil {
		return nil, err
	}

	targetIDs := make([]string, 0, len(links))
	for _, link := range links {
		targetIDs = append(targetIDs, link.Target)
	}

	loaded, err := l.BookByID.LoadMany(ctx, targetIDs)
	if err != nil {
		return nil, err
	}

	for _, link := range links {
		item := loaded[link.Target]
		if item == nil {
			continue
		}
		result[link.Source] = append(result[link.Source], item)
	}

	for _, key := range dedup {
		result[key] = result[key]
	}

	for key := range result {
		sort.SliceStable(result[key], func(i, j int) bool {
			left := result[key][i]
			right := result[key][j]
			return stringValue(left.Id) < stringValue(right.Id)
		})
	}

	return result, nil
}

type pivotLink struct {
	Source string `bun:"source_id"`
	Target string `bun:"target_id"`
}

func fetchPivotLinks(ctx context.Context, db bun.IDB, table, sourceColumn, targetColumn string, keys []string) ([]pivotLink, error) {
	rows := make([]pivotLink, 0, len(keys))
	if len(keys) == 0 {
		return rows, nil
	}

	err := db.NewSelect().
		Table(table).
		ColumnExpr("? AS source_id", bun.Ident(sourceColumn)).
		ColumnExpr("? AS target_id", bun.Ident(targetColumn)).
		Where(fmt.Sprintf("%s IN (?)", bun.Ident(sourceColumn)), bun.In(uniqueKeys(keys))).
		Scan(ctx, &rows)

	return rows, err
}

type entityLoader[T any] struct {
	fetch func(context.Context, []string) (map[string]*T, error)
	mu    sync.Mutex
	cache map[string]*T
}

func newEntityLoader[T any](fetch func(context.Context, []string) (map[string]*T, error)) *entityLoader[T] {
	return &entityLoader[T]{
		fetch: fetch,
		cache: make(map[string]*T),
	}
}

func (l *entityLoader[T]) Load(ctx context.Context, key string) (*T, error) {
	items, err := l.LoadMany(ctx, []string{key})
	if err != nil {
		return nil, err
	}
	return items[key], nil
}

func (l *entityLoader[T]) LoadMany(ctx context.Context, keys []string) (map[string]*T, error) {
	result := make(map[string]*T, len(keys))
	missing := make([]string, 0, len(keys))
	dedup := uniqueKeys(keys)

	l.mu.Lock()
	for _, key := range dedup {
		if val, ok := l.cache[key]; ok {
			result[key] = val
			continue
		}
		missing = append(missing, key)
	}
	l.mu.Unlock()

	if len(missing) > 0 {
		fetched, err := l.fetch(ctx, missing)
		if err != nil {
			return nil, err
		}
		l.mu.Lock()
		for key, val := range fetched {
			l.cache[key] = val
			result[key] = val
		}
		l.mu.Unlock()
	}

	for _, key := range dedup {
		if _, ok := result[key]; !ok {
			result[key] = nil
		}
	}

	return result, nil
}

type groupLoader[T any] struct {
	fetch func(context.Context, []string) (map[string][]*T, error)
	mu    sync.Mutex
	cache map[string][]*T
}

func newGroupLoader[T any](fetch func(context.Context, []string) (map[string][]*T, error)) *groupLoader[T] {
	return &groupLoader[T]{
		fetch: fetch,
		cache: make(map[string][]*T),
	}
}

func (l *groupLoader[T]) Load(ctx context.Context, key string) ([]*T, error) {
	items, err := l.LoadMany(ctx, []string{key})
	if err != nil {
		return nil, err
	}
	return items[key], nil
}

func (l *groupLoader[T]) LoadMany(ctx context.Context, keys []string) (map[string][]*T, error) {
	result := make(map[string][]*T, len(keys))
	missing := make([]string, 0, len(keys))
	dedup := uniqueKeys(keys)

	l.mu.Lock()
	for _, key := range dedup {
		if val, ok := l.cache[key]; ok {
			result[key] = val
			continue
		}
		missing = append(missing, key)
	}
	l.mu.Unlock()

	if len(missing) > 0 {
		fetched, err := l.fetch(ctx, missing)
		if err != nil {
			return nil, err
		}

		l.mu.Lock()
		for key, val := range fetched {
			l.cache[key] = val
			result[key] = val
		}
		l.mu.Unlock()
	}

	for _, key := range dedup {
		if _, ok := result[key]; !ok {
			result[key] = nil
		}
	}

	return result, nil
}

func uniqueKeys(keys []string) []string {
	seen := make(map[string]struct{}, len(keys))
	result := make([]string, 0, len(keys))
	for _, key := range keys {
		key = strings.TrimSpace(key)
		if key == "" {
			continue
		}
		if _, ok := seen[key]; ok {
			continue
		}
		seen[key] = struct{}{}
		result = append(result, key)
	}
	return result
}

func stringValue(value any) string {
	switch v := value.(type) {
	case nil:
		return ""
	case *string:
		if v == nil {
			return ""
		}
		return *v
	case fmt.Stringer:
		return v.String()
	default:
		return fmt.Sprint(v)
	}
}
